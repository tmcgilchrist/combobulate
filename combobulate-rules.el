;; -*- lexical-binding: t -*-
;; This file is generated by build-relationships.py
;; Do not edit this file directly.

;; START Production rules for yaml
(defconst combobulate-rules-yaml
 '(("alias" (:*unnamed* ("alias_name")))
 ("alias_name" (:*unnamed* nil))
 ("anchor" (:*unnamed* ("anchor_name")))
 ("anchor_name" (:*unnamed* nil))
 ("block_mapping" (:*unnamed* ("block_mapping_pair")))
 ("block_mapping_pair" (:*unnamed* nil :key ("flow_node" "block_node") :value ("flow_node" "block_node")))
 ("block_node" (:*unnamed* ("block_scalar" "block_sequence" "block_mapping" "anchor" "tag")))
 ("block_scalar" (:*unnamed* nil))
 ("block_sequence" (:*unnamed* ("block_sequence_item")))
 ("block_sequence_item" (:*unnamed* ("flow_node" "block_node")))
 ("boolean_scalar" (:*unnamed* nil))
 ("comment" (:*unnamed* nil))
 ("directive_name" (:*unnamed* nil))
 ("directive_parameter" (:*unnamed* nil))
 ("document" (:*unnamed* ("flow_node" "tag_directive" "yaml_directive" "block_node" "reserved_directive")))
 ("double_quote_scalar" (:*unnamed* ("escape_sequence")))
 ("escape_sequence" (:*unnamed* nil))
 ("float_scalar" (:*unnamed* nil))
 ("flow_mapping" (:*unnamed* ("flow_node" "flow_pair")))
 ("flow_node" (:*unnamed* ("alias" "plain_scalar" "tag" "flow_mapping" "double_quote_scalar" "flow_sequence" "single_quote_scalar" "anchor")))
 ("flow_pair" (:*unnamed* nil :key ("flow_node") :value ("flow_node")))
 ("flow_sequence" (:*unnamed* ("flow_node" "flow_pair")))
 ("integer_scalar" (:*unnamed* nil))
 ("null_scalar" (:*unnamed* nil))
 ("plain_scalar" (:*unnamed* ("null_scalar" "string_scalar" "float_scalar" "boolean_scalar" "integer_scalar")))
 ("reserved_directive" (:*unnamed* ("directive_parameter" "directive_name")))
 ("single_quote_scalar" (:*unnamed* ("escape_sequence")))
 ("stream" (:*unnamed* ("document")))
 ("string_scalar" (:*unnamed* nil))
 ("tag" (:*unnamed* nil))
 ("tag_directive" (:*unnamed* ("tag_prefix" "tag_handle")))
 ("tag_handle" (:*unnamed* nil))
 ("tag_prefix" (:*unnamed* nil))
 ("yaml_directive" (:*unnamed* ("yaml_version")))
 ("yaml_version" (:*unnamed* nil))
))
;; END Production rules for yaml
;; START Inverse production rules for yaml
(defconst combobulate-rules-yaml-inverse
 '(("alias" ("flow_node"))
   ("alias_name" ("alias"))
   ("anchor" ("flow_node" "block_node"))
   ("anchor_name" ("anchor"))
   ("block_mapping" ("block_node"))
   ("block_mapping_pair" ("block_mapping"))
   ("block_node" ("block_mapping_pair" "document" "block_sequence_item"))
   ("block_scalar" ("block_node"))
   ("block_sequence" ("block_node"))
   ("block_sequence_item" ("block_sequence"))
   ("boolean_scalar" ("plain_scalar"))
   ("directive_name" ("reserved_directive"))
   ("directive_parameter" ("reserved_directive"))
   ("document" ("stream"))
   ("double_quote_scalar" ("flow_node"))
   ("escape_sequence" ("single_quote_scalar" "double_quote_scalar"))
   ("float_scalar" ("plain_scalar"))
   ("flow_mapping" ("flow_node"))
   ("flow_node" ("block_mapping_pair" "block_sequence_item" "flow_pair" "flow_mapping" "flow_sequence" "document"))
   ("flow_pair" ("flow_mapping" "flow_sequence"))
   ("flow_sequence" ("flow_node"))
   ("integer_scalar" ("plain_scalar"))
   ("null_scalar" ("plain_scalar"))
   ("plain_scalar" ("flow_node"))
   ("reserved_directive" ("document"))
   ("single_quote_scalar" ("flow_node"))
   ("string_scalar" ("plain_scalar"))
   ("tag" ("flow_node" "block_node"))
   ("tag_directive" ("document"))
   ("tag_handle" ("tag_directive"))
   ("tag_prefix" ("tag_directive"))
   ("yaml_directive" ("document"))
   ("yaml_version" ("yaml_directive"))
  )
)
;; END Inverse production rules for yaml
;; START All node types in yaml
(defconst combobulate-rules-yaml-types
 '("alias" "alias_name" "anchor" "anchor_name" "block_mapping" "block_mapping_pair" "block_node" "block_scalar" "block_sequence" "block_sequence_item" "boolean_scalar" "comment" "directive_name" "directive_parameter" "document" "double_quote_scalar" "escape_sequence" "float_scalar" "flow_mapping" "flow_node" "flow_pair" "flow_sequence" "integer_scalar" "null_scalar" "plain_scalar" "reserved_directive" "single_quote_scalar" "stream" "string_scalar" "tag" "tag_directive" "tag_handle" "tag_prefix" "yaml_directive" "yaml_version")
)
;; END All node types in yaml
;; START All supertypes in yaml
(defconst combobulate-rules-yaml-supertypes
 nil
)
;; END All supertypes in yaml

;; START Production rules for tsx
(defconst combobulate-rules-tsx
 '(("_primary_type" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query")))
 ("abstract_class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
 ("abstract_method_signature" (:*unnamed* ("accessibility_modifier") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("accessibility_modifier" (:*unnamed* nil))
 ("ambient_declaration" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "property_identifier" "existential_type" "declaration" "readonly_type" "statement_block" "type_query" "infer_type")))
 ("arguments" (:*unnamed* ("spread_element" "expression")))
 ("array" (:*unnamed* ("spread_element" "expression")))
 ("array_pattern" (:*unnamed* ("pattern" "assignment_pattern")))
 ("array_type" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query")))
 ("arrow_function" (:*unnamed* nil :body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("as_expression" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "expression" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("asserts" (:*unnamed* ("identifier" "type_predicate" "this")))
 ("asserts_annotation" (:*unnamed* ("asserts")))
 ("assignment_expression" (:*unnamed* nil :left ("member_expression" "object_pattern" "subscript_expression" "non_null_expression" "array_pattern" "identifier" "undefined" "parenthesized_expression") :right ("expression")))
 ("assignment_pattern" (:*unnamed* nil :left ("pattern") :right ("expression")))
 ("augmented_assignment_expression" (:*unnamed* nil :left ("identifier" "member_expression" "subscript_expression" "non_null_expression" "parenthesized_expression") :operator nil :right ("expression")))
 ("await_expression" (:*unnamed* ("expression")))
 ("binary_expression" (:*unnamed* nil :left ("expression") :operator nil :right ("expression")))
 ("break_statement" (:*unnamed* nil :label ("statement_identifier")))
 ("call_expression" (:*unnamed* nil :arguments ("arguments" "template_string") :function ("expression") :type_arguments ("type_arguments")))
 ("call_signature" (:*unnamed* nil :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("catch_clause" (:*unnamed* nil :body ("statement_block") :parameter ("identifier" "object_pattern" "array_pattern") :type ("type_annotation")))
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
 ("class_body" (:*unnamed* ("class_static_block" "method_definition" "abstract_method_signature" "decorator" "index_signature" "method_signature" "public_field_definition")))
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
 ("class_heritage" (:*unnamed* ("implements_clause" "extends_clause")))
 ("class_static_block" (:*unnamed* nil :body ("statement_block")))
 ("comment" (:*unnamed* nil))
 ("computed_property_name" (:*unnamed* ("expression")))
 ("conditional_type" (:*unnamed* nil :alternative ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :consequence ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :left ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :right ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("constraint" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("construct_signature" (:*unnamed* nil :parameters ("formal_parameters") :type ("type_annotation") :type_parameters ("type_parameters")))
 ("constructor_type" (:*unnamed* nil :parameters ("formal_parameters") :type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :type_parameters ("type_parameters")))
 ("continue_statement" (:*unnamed* nil :label ("statement_identifier")))
 ("debugger_statement" (:*unnamed* nil))
 ("declaration" (:*unnamed* ("interface_declaration" "variable_declaration" "import_alias" "lexical_declaration" "module" "generator_function_declaration" "ambient_declaration" "enum_declaration" "class_declaration" "type_alias_declaration" "function_signature" "function_declaration" "internal_module" "abstract_class_declaration")))
 ("decorator" (:*unnamed* ("identifier" "member_expression" "call_expression")))
 ("default_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("do_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression")))
 ("else_clause" (:*unnamed* ("statement")))
 ("empty_statement" (:*unnamed* nil))
 ("enum_assignment" (:*unnamed* nil :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("expression")))
 ("enum_body" (:*unnamed* ("enum_assignment") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier")))
 ("enum_declaration" (:*unnamed* nil :body ("enum_body") :name ("identifier")))
 ("escape_sequence" (:*unnamed* nil))
 ("existential_type" (:*unnamed* nil))
 ("export_clause" (:*unnamed* ("export_specifier")))
 ("export_specifier" (:*unnamed* nil :alias ("identifier" "string") :name ("identifier" "string")))
 ("export_statement" (:*unnamed* ("identifier" "namespace_export" "export_clause" "expression") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression")))
 ("expression" (:*unnamed* ("augmented_assignment_expression" "ternary_expression" "instantiation_expression" "jsx_element" "unary_expression" "jsx_self_closing_element" "internal_module" "update_expression" "glimmer_template" "satisfies_expression" "binary_expression" "await_expression" "assignment_expression" "new_expression" "primary_expression" "as_expression" "yield_expression")))
 ("expression_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("extends_clause" (:*unnamed* nil :type_arguments ("type_arguments") :value ("expression")))
 ("extends_type_clause" (:*unnamed* nil :type ("type_identifier" "generic_type" "nested_type_identifier")))
 ("false" (:*unnamed* nil))
 ("finally_clause" (:*unnamed* nil :body ("statement_block")))
 ("flow_maybe_type" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query")))
 ("for_in_statement" (:*unnamed* nil :body ("statement") :kind nil :left ("member_expression" "object_pattern" "subscript_expression" "non_null_expression" "array_pattern" "identifier" "undefined" "parenthesized_expression") :operator nil :right ("sequence_expression" "expression") :value ("expression")))
 ("for_statement" (:*unnamed* nil :body ("statement") :condition ("expression_statement" "empty_statement") :increment ("sequence_expression" "expression") :initializer ("expression_statement" "lexical_declaration" "empty_statement" "variable_declaration")))
 ("formal_parameters" (:*unnamed* ("optional_parameter" "required_parameter")))
 ("function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("function_signature" (:*unnamed* nil :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("function_type" (:*unnamed* nil :parameters ("formal_parameters") :return_type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "asserts" "flow_maybe_type" "type_predicate" "existential_type" "readonly_type" "type_query" "infer_type") :type_parameters ("type_parameters")))
 ("generator_function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("generator_function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("generic_type" (:*unnamed* nil :name ("type_identifier" "nested_type_identifier") :type_arguments ("type_arguments")))
 ("glimmer_closing_tag" (:*unnamed* nil))
 ("glimmer_opening_tag" (:*unnamed* nil))
 ("glimmer_template" (:*unnamed* nil :close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag")))
 ("hash_bang_line" (:*unnamed* nil))
 ("identifier" (:*unnamed* nil))
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement")))
 ("implements_clause" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("import" (:*unnamed* nil))
 ("import_alias" (:*unnamed* ("identifier" "nested_identifier")))
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports")))
 ("import_require_clause" (:*unnamed* ("identifier") :source ("string")))
 ("import_specifier" (:*unnamed* nil :alias ("identifier") :name ("identifier" "string")))
 ("import_statement" (:*unnamed* ("import_require_clause" "import_clause") :source ("string")))
 ("index_signature" (:*unnamed* ("mapped_type_clause") :index_type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :name ("identifier") :sign nil :type ("opting_type_annotation" "type_annotation" "omitting_type_annotation")))
 ("index_type_query" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query")))
 ("infer_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("instantiation_expression" (:*unnamed* ("expression") :function ("identifier" "subscript_expression" "import" "member_expression") :type_arguments ("type_arguments")))
 ("interface_declaration" (:*unnamed* ("extends_type_clause") :body ("object_type") :name ("type_identifier") :type_parameters ("type_parameters")))
 ("internal_module" (:*unnamed* nil :body ("statement_block") :name ("identifier" "string" "nested_identifier")))
 ("intersection_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("jsx_attribute" (:*unnamed* ("property_identifier" "jsx_element" "jsx_namespace_name" "jsx_self_closing_element" "string" "jsx_expression")))
 ("jsx_closing_element" (:*unnamed* nil :name ("identifier" "member_expression" "jsx_namespace_name")))
 ("jsx_element" (:*unnamed* ("jsx_element" "jsx_text" "jsx_expression" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element")))
 ("jsx_expression" (:*unnamed* ("sequence_expression" "spread_element" "expression")))
 ("jsx_namespace_name" (:*unnamed* ("identifier")))
 ("jsx_opening_element" (:*unnamed* nil :attribute ("jsx_expression" "jsx_attribute") :name ("identifier" "member_expression" "jsx_namespace_name") :type_arguments ("type_arguments")))
 ("jsx_self_closing_element" (:*unnamed* nil :attribute ("jsx_expression" "jsx_attribute") :name ("identifier" "member_expression" "jsx_namespace_name") :type_arguments ("type_arguments")))
 ("jsx_text" (:*unnamed* nil))
 ("labeled_statement" (:*unnamed* nil :body ("statement") :label ("statement_identifier")))
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil))
 ("literal_type" (:*unnamed* ("null" "undefined" "unary_expression" "false" "string" "number" "true")))
 ("lookup_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("mapped_type_clause" (:*unnamed* nil :alias ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :name ("type_identifier") :type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("member_expression" (:*unnamed* ("identifier" "property_identifier" "member_expression") :object ("expression") :optional_chain ("optional_chain") :property ("property_identifier" "private_property_identifier")))
 ("meta_property" (:*unnamed* nil))
 ("method_definition" (:*unnamed* ("override_modifier" "accessibility_modifier") :body ("statement_block") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("method_signature" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("module" (:*unnamed* nil :body ("statement_block") :name ("identifier" "string" "nested_identifier")))
 ("named_imports" (:*unnamed* ("import_specifier")))
 ("namespace_export" (:*unnamed* ("identifier" "string")))
 ("namespace_import" (:*unnamed* ("identifier")))
 ("nested_identifier" (:*unnamed* ("identifier" "property_identifier" "member_expression")))
 ("nested_type_identifier" (:*unnamed* nil :module ("identifier" "nested_identifier") :name ("type_identifier")))
 ("new_expression" (:*unnamed* nil :arguments ("arguments") :constructor ("primary_expression") :type_arguments ("type_arguments")))
 ("non_null_expression" (:*unnamed* ("expression")))
 ("null" (:*unnamed* nil))
 ("number" (:*unnamed* nil))
 ("object" (:*unnamed* ("pair" "method_definition" "shorthand_property_identifier" "spread_element")))
 ("object_assignment_pattern" (:*unnamed* nil :left ("object_pattern" "shorthand_property_identifier_pattern" "array_pattern") :right ("expression")))
 ("object_pattern" (:*unnamed* ("pair_pattern" "shorthand_property_identifier_pattern" "object_assignment_pattern" "rest_pattern")))
 ("object_type" (:*unnamed* ("property_signature" "export_statement" "index_signature" "call_signature" "method_signature" "construct_signature")))
 ("omitting_type_annotation" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("opting_type_annotation" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("optional_chain" (:*unnamed* nil))
 ("optional_parameter" (:*unnamed* ("override_modifier" "accessibility_modifier") :decorator ("decorator") :name ("identifier") :pattern ("pattern" "this") :type ("type_annotation") :value ("expression")))
 ("optional_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("override_modifier" (:*unnamed* nil))
 ("pair" (:*unnamed* nil :key ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("expression")))
 ("pair_pattern" (:*unnamed* nil :key ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("pattern" "assignment_pattern")))
 ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression") :type ("type_annotation")))
 ("parenthesized_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("pattern" (:*unnamed* ("member_expression" "object_pattern" "subscript_expression" "non_null_expression" "array_pattern" "identifier" "undefined" "rest_pattern")))
 ("predefined_type" (:*unnamed* nil))
 ("primary_expression" (:*unnamed* ("arrow_function" "meta_property" "regex" "member_expression" "false" "generator_function" "string" "subscript_expression" "non_null_expression" "true" "null" "this" "object" "class" "template_string" "array" "super" "import" "number" "identifier" "undefined" "function" "call_expression" "parenthesized_expression")))
 ("private_property_identifier" (:*unnamed* nil))
 ("program" (:*unnamed* ("statement" "hash_bang_line")))
 ("property_identifier" (:*unnamed* nil))
 ("property_signature" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :type ("type_annotation")))
 ("public_field_definition" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :type ("type_annotation") :value ("expression")))
 ("readonly_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("regex" (:*unnamed* nil :flags ("regex_flags") :pattern ("regex_pattern")))
 ("regex_flags" (:*unnamed* nil))
 ("regex_pattern" (:*unnamed* nil))
 ("required_parameter" (:*unnamed* ("override_modifier" "accessibility_modifier") :decorator ("decorator") :name ("identifier" "rest_pattern") :pattern ("pattern" "this") :type ("type_annotation") :value ("expression")))
 ("rest_pattern" (:*unnamed* ("identifier" "undefined" "member_expression" "object_pattern" "subscript_expression" "non_null_expression" "array_pattern")))
 ("rest_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("return_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("satisfies_expression" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "expression" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("sequence_expression" (:*unnamed* nil :left ("expression") :right ("sequence_expression" "expression")))
 ("shorthand_property_identifier" (:*unnamed* nil))
 ("shorthand_property_identifier_pattern" (:*unnamed* nil))
 ("spread_element" (:*unnamed* ("expression")))
 ("statement" (:*unnamed* ("import_statement" "expression_statement" "return_statement" "labeled_statement" "continue_statement" "throw_statement" "debugger_statement" "break_statement" "if_statement" "try_statement" "do_statement" "empty_statement" "while_statement" "declaration" "for_statement" "statement_block" "with_statement" "for_in_statement" "export_statement" "switch_statement")))
 ("statement_block" (:*unnamed* ("statement")))
 ("statement_identifier" (:*unnamed* nil))
 ("string" (:*unnamed* ("escape_sequence" "string_fragment")))
 ("string_fragment" (:*unnamed* nil))
 ("subscript_expression" (:*unnamed* nil :index ("predefined_type" "sequence_expression" "expression" "string" "number") :object ("expression") :optional_chain ("optional_chain")))
 ("super" (:*unnamed* nil))
 ("switch_body" (:*unnamed* ("switch_case" "switch_default")))
 ("switch_case" (:*unnamed* nil :body ("statement") :value ("sequence_expression" "expression")))
 ("switch_default" (:*unnamed* nil :body ("statement")))
 ("switch_statement" (:*unnamed* nil :body ("switch_body") :value ("parenthesized_expression")))
 ("template_literal_type" (:*unnamed* ("template_type")))
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution")))
 ("template_substitution" (:*unnamed* ("sequence_expression" "expression")))
 ("template_type" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query" "infer_type")))
 ("ternary_expression" (:*unnamed* nil :alternative ("expression") :condition ("expression") :consequence ("expression")))
 ("this" (:*unnamed* nil))
 ("this_type" (:*unnamed* nil))
 ("throw_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("true" (:*unnamed* nil))
 ("try_statement" (:*unnamed* nil :body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause")))
 ("tuple_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "optional_type" "array_type" "predefined_type" "optional_parameter" "template_literal_type" "required_parameter" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "rest_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_alias_declaration" (:*unnamed* nil :name ("type_identifier") :type_parameters ("type_parameters") :value ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_annotation" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_arguments" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_identifier" (:*unnamed* nil))
 ("type_parameter" (:*unnamed* nil :constraint ("constraint") :name ("type_identifier") :value ("default_type")))
 ("type_parameters" (:*unnamed* ("type_parameter")))
 ("type_predicate" (:*unnamed* nil :name ("identifier" "this") :type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_predicate_annotation" (:*unnamed* ("type_predicate")))
 ("type_query" (:*unnamed* ("identifier" "instantiation_expression" "member_expression" "subscript_expression" "call_expression")))
 ("unary_expression" (:*unnamed* nil :argument ("number" "expression") :operator nil))
 ("undefined" (:*unnamed* nil))
 ("union_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("update_expression" (:*unnamed* nil :argument ("expression") :operator nil))
 ("variable_declaration" (:*unnamed* ("variable_declarator")))
 ("variable_declarator" (:*unnamed* nil :name ("identifier" "object_pattern" "array_pattern") :type ("type_annotation") :value ("expression")))
 ("while_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression")))
 ("with_statement" (:*unnamed* nil :body ("statement") :object ("parenthesized_expression")))
 ("yield_expression" (:*unnamed* ("expression")))
))
;; END Production rules for tsx
;; START Inverse production rules for tsx
(defconst combobulate-rules-tsx-inverse
 '(("abstract_class_declaration" ("declaration"))
   ("abstract_method_signature" ("class_body"))
   ("accessibility_modifier" ("method_definition" "abstract_method_signature" "public_field_definition" "property_signature" "optional_parameter" "required_parameter" "method_signature"))
   ("ambient_declaration" ("declaration"))
   ("arguments" ("new_expression" "call_expression"))
   ("array" ("primary_expression"))
   ("array_pattern" ("pattern" "object_assignment_pattern" "assignment_expression" "catch_clause" "rest_pattern" "for_in_statement" "variable_declarator"))
   ("array_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("arrow_function" ("primary_expression"))
   ("as_expression" ("expression"))
   ("asserts" ("asserts_annotation" "function_type"))
   ("asserts_annotation" ("arrow_function" "method_definition" "abstract_method_signature" "function" "generator_function" "call_signature" "generator_function_declaration" "function_signature" "function_declaration" "method_signature"))
   ("assignment_expression" ("expression"))
   ("assignment_pattern" ("pair_pattern" "array_pattern"))
   ("augmented_assignment_expression" ("expression"))
   ("await_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("break_statement" ("statement"))
   ("call_expression" ("primary_expression" "type_query" "decorator"))
   ("call_signature" ("object_type"))
   ("catch_clause" ("try_statement"))
   ("class" ("primary_expression"))
   ("class_body" ("class_declaration" "class" "abstract_class_declaration"))
   ("class_declaration" ("declaration"))
   ("class_heritage" ("class_declaration" "class" "abstract_class_declaration"))
   ("class_static_block" ("class_body"))
   ("computed_property_name" ("pair" "method_definition" "abstract_method_signature" "enum_body" "public_field_definition" "property_signature" "enum_assignment" "pair_pattern" "method_signature"))
   ("conditional_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("constraint" ("type_parameter"))
   ("construct_signature" ("object_type"))
   ("constructor_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "as_expression"))
   ("continue_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("ambient_declaration" "statement" "export_statement"))
   ("decorator" ("required_parameter" "class_body" "optional_parameter" "abstract_class_declaration" "class_declaration" "class" "export_statement"))
   ("default_type" ("type_parameter"))
   ("do_statement" ("statement"))
   ("else_clause" ("if_statement"))
   ("empty_statement" ("for_statement" "statement"))
   ("enum_assignment" ("enum_body"))
   ("enum_body" ("enum_declaration"))
   ("enum_declaration" ("declaration"))
   ("escape_sequence" ("string" "template_string"))
   ("existential_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("export_clause" ("export_statement"))
   ("export_specifier" ("export_clause"))
   ("export_statement" ("object_type" "statement"))
   ("expression" ("arrow_function" "computed_property_name" "member_expression" "augmented_assignment_expression" "ternary_expression" "optional_parameter" "instantiation_expression" "template_substitution" "unary_expression" "throw_statement" "required_parameter" "update_expression" "pair" "arguments" "binary_expression" "for_statement" "for_in_statement" "array" "export_statement" "yield_expression" "expression_statement" "subscript_expression" "non_null_expression" "public_field_definition" "return_statement" "sequence_expression" "extends_clause" "switch_case" "assignment_pattern" "variable_declarator" "satisfies_expression" "await_expression" "object_assignment_pattern" "jsx_expression" "assignment_expression" "enum_assignment" "spread_element" "as_expression" "call_expression" "parenthesized_expression"))
   ("expression_statement" ("for_statement" "statement"))
   ("extends_clause" ("class_heritage"))
   ("extends_type_clause" ("interface_declaration"))
   ("false" ("primary_expression" "literal_type"))
   ("finally_clause" ("try_statement"))
   ("flow_maybe_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("for_in_statement" ("statement"))
   ("for_statement" ("statement"))
   ("formal_parameters" ("arrow_function" "function_type" "abstract_method_signature" "constructor_type" "method_definition" "method_signature" "generator_function" "call_signature" "generator_function_declaration" "function_signature" "function" "function_declaration" "construct_signature"))
   ("function" ("primary_expression"))
   ("function_declaration" ("declaration"))
   ("function_signature" ("declaration"))
   ("function_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "as_expression"))
   ("generator_function" ("primary_expression"))
   ("generator_function_declaration" ("declaration"))
   ("generic_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "extends_type_clause" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("glimmer_template" ("expression"))
   ("hash_bang_line" ("program"))
   ("identifier" ("arrow_function" "jsx_closing_element" "namespace_import" "member_expression" "augmented_assignment_expression" "index_signature" "optional_parameter" "instantiation_expression" "rest_pattern" "function_declaration" "internal_module" "required_parameter" "import_alias" "decorator" "asserts" "module" "generator_function_declaration" "enum_declaration" "import_specifier" "nested_identifier" "function" "for_in_statement" "export_statement" "import_clause" "jsx_self_closing_element" "function_signature" "export_specifier" "variable_declarator" "import_require_clause" "pattern" "nested_type_identifier" "namespace_export" "assignment_expression" "catch_clause" "type_predicate" "jsx_namespace_name" "jsx_opening_element" "primary_expression" "type_query" "generator_function"))
   ("if_statement" ("statement"))
   ("implements_clause" ("class_heritage"))
   ("import" ("primary_expression" "instantiation_expression"))
   ("import_alias" ("declaration"))
   ("import_clause" ("import_statement"))
   ("import_require_clause" ("import_statement"))
   ("import_specifier" ("named_imports"))
   ("import_statement" ("statement"))
   ("index_signature" ("object_type" "class_body"))
   ("index_type_query" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("infer_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "as_expression"))
   ("instantiation_expression" ("type_query" "expression"))
   ("interface_declaration" ("declaration"))
   ("internal_module" ("declaration" "expression"))
   ("intersection_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_element" ("jsx_element" "jsx_attribute" "expression"))
   ("jsx_expression" ("jsx_self_closing_element" "jsx_element" "jsx_opening_element" "jsx_attribute"))
   ("jsx_namespace_name" ("jsx_closing_element" "jsx_self_closing_element" "jsx_opening_element" "jsx_attribute"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_self_closing_element" ("jsx_element" "jsx_attribute" "expression"))
   ("jsx_text" ("jsx_element"))
   ("labeled_statement" ("statement"))
   ("lexical_declaration" ("for_statement" "declaration"))
   ("literal_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("lookup_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("mapped_type_clause" ("index_signature"))
   ("member_expression" ("jsx_closing_element" "pattern" "augmented_assignment_expression" "member_expression" "nested_identifier" "decorator" "rest_pattern" "assignment_expression" "instantiation_expression" "jsx_opening_element" "jsx_self_closing_element" "primary_expression" "type_query" "for_in_statement"))
   ("meta_property" ("primary_expression"))
   ("method_definition" ("object" "class_body"))
   ("method_signature" ("object_type" "class_body"))
   ("module" ("declaration"))
   ("named_imports" ("import_clause"))
   ("namespace_export" ("export_statement"))
   ("namespace_import" ("import_clause"))
   ("nested_identifier" ("module" "internal_module" "nested_type_identifier" "import_alias"))
   ("nested_type_identifier" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "generic_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "extends_type_clause" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("new_expression" ("expression"))
   ("non_null_expression" ("pattern" "augmented_assignment_expression" "rest_pattern" "assignment_expression" "primary_expression" "for_in_statement"))
   ("null" ("primary_expression" "literal_type"))
   ("number" ("pair" "method_definition" "abstract_method_signature" "pair_pattern" "literal_type" "subscript_expression" "enum_body" "public_field_definition" "property_signature" "enum_assignment" "unary_expression" "primary_expression" "method_signature"))
   ("object" ("primary_expression"))
   ("object_assignment_pattern" ("object_pattern"))
   ("object_pattern" ("pattern" "object_assignment_pattern" "assignment_expression" "catch_clause" "rest_pattern" "for_in_statement" "variable_declarator"))
   ("object_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "interface_declaration" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("omitting_type_annotation" ("index_signature"))
   ("opting_type_annotation" ("index_signature"))
   ("optional_chain" ("subscript_expression" "member_expression"))
   ("optional_parameter" ("formal_parameters" "tuple_type"))
   ("optional_type" ("tuple_type"))
   ("override_modifier" ("method_definition" "public_field_definition" "property_signature" "optional_parameter" "required_parameter" "method_signature"))
   ("pair" ("object"))
   ("pair_pattern" ("object_pattern"))
   ("parenthesized_expression" ("if_statement" "augmented_assignment_expression" "assignment_expression" "do_statement" "while_statement" "primary_expression" "with_statement" "for_in_statement" "switch_statement"))
   ("parenthesized_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("pattern" ("array_pattern" "optional_parameter" "pair_pattern" "required_parameter" "assignment_pattern"))
   ("predefined_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "subscript_expression" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("primary_expression" ("new_expression" "expression"))
   ("private_property_identifier" ("pair" "method_definition" "abstract_method_signature" "member_expression" "enum_body" "public_field_definition" "property_signature" "enum_assignment" "pair_pattern" "method_signature"))
   ("property_identifier" ("pair" "method_definition" "abstract_method_signature" "member_expression" "enum_body" "public_field_definition" "ambient_declaration" "property_signature" "enum_assignment" "nested_identifier" "pair_pattern" "method_signature" "jsx_attribute"))
   ("property_signature" ("object_type"))
   ("public_field_definition" ("class_body"))
   ("readonly_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "as_expression"))
   ("regex" ("primary_expression"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("required_parameter" ("formal_parameters" "tuple_type"))
   ("rest_pattern" ("object_pattern" "pattern" "required_parameter"))
   ("rest_type" ("tuple_type"))
   ("return_statement" ("statement"))
   ("satisfies_expression" ("expression"))
   ("sequence_expression" ("expression_statement" "subscript_expression" "jsx_expression" "return_statement" "sequence_expression" "switch_case" "template_substitution" "for_statement" "throw_statement" "for_in_statement" "parenthesized_expression"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_pattern" "object_assignment_pattern"))
   ("spread_element" ("object" "arguments" "jsx_expression" "array"))
   ("statement" ("if_statement" "else_clause" "do_statement" "program" "switch_case" "statement_block" "switch_default" "for_statement" "while_statement" "with_statement" "for_in_statement" "labeled_statement"))
   ("statement_block" ("arrow_function" "class_static_block" "method_definition" "try_statement" "generator_function" "finally_clause" "internal_module" "module" "generator_function_declaration" "ambient_declaration" "statement" "catch_clause" "function" "function_declaration"))
   ("statement_identifier" ("break_statement" "continue_statement" "labeled_statement"))
   ("string" ("literal_type" "enum_body" "property_signature" "internal_module" "pair" "module" "import_specifier" "export_statement" "method_definition" "import_statement" "subscript_expression" "public_field_definition" "pair_pattern" "method_signature" "export_specifier" "jsx_attribute" "abstract_method_signature" "import_require_clause" "namespace_export" "enum_assignment" "primary_expression"))
   ("string_fragment" ("string"))
   ("subscript_expression" ("pattern" "augmented_assignment_expression" "rest_pattern" "assignment_expression" "instantiation_expression" "primary_expression" "type_query" "for_in_statement"))
   ("super" ("primary_expression"))
   ("switch_body" ("switch_statement"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_statement" ("statement"))
   ("template_literal_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("template_string" ("primary_expression" "call_expression"))
   ("template_substitution" ("template_string"))
   ("template_type" ("template_literal_type"))
   ("ternary_expression" ("expression"))
   ("this" ("asserts" "optional_parameter" "type_predicate" "primary_expression" "required_parameter"))
   ("this_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("throw_statement" ("statement"))
   ("true" ("primary_expression" "literal_type"))
   ("try_statement" ("statement"))
   ("tuple_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("type_alias_declaration" ("declaration"))
   ("type_annotation" ("arrow_function" "call_signature" "index_signature" "property_signature" "optional_parameter" "required_parameter" "function_declaration" "generator_function_declaration" "function" "method_definition" "public_field_definition" "function_signature" "method_signature" "construct_signature" "variable_declarator" "abstract_method_signature" "catch_clause" "generator_function" "parenthesized_expression"))
   ("type_arguments" ("generic_type" "new_expression" "instantiation_expression" "extends_clause" "jsx_opening_element" "jsx_self_closing_element" "call_expression"))
   ("type_identifier" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_parameter" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "generic_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "class" "default_type" "parenthesized_type" "implements_clause" "interface_declaration" "lookup_type" "nested_type_identifier" "satisfies_expression" "extends_type_clause" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "class_declaration" "as_expression" "abstract_class_declaration"))
   ("type_parameter" ("type_parameters"))
   ("type_parameters" ("arrow_function" "construct_signature" "abstract_method_signature" "constructor_type" "function_type" "function" "interface_declaration" "generator_function" "method_definition" "method_signature" "call_signature" "generator_function_declaration" "class_declaration" "type_alias_declaration" "function_signature" "class" "function_declaration" "abstract_class_declaration"))
   ("type_predicate" ("function_type" "asserts" "type_predicate_annotation"))
   ("type_predicate_annotation" ("arrow_function" "method_definition" "abstract_method_signature" "function" "generator_function" "call_signature" "generator_function_declaration" "function_signature" "function_declaration" "method_signature"))
   ("type_query" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("unary_expression" ("literal_type" "expression"))
   ("undefined" ("pattern" "literal_type" "rest_pattern" "assignment_expression" "primary_expression" "for_in_statement"))
   ("union_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("update_expression" ("expression"))
   ("variable_declaration" ("for_statement" "declaration"))
   ("variable_declarator" ("lexical_declaration" "variable_declaration"))
   ("while_statement" ("statement"))
   ("with_statement" ("statement"))
   ("yield_expression" ("expression"))
  )
)
;; END Inverse production rules for tsx
;; START All node types in tsx
(defconst combobulate-rules-tsx-types
 '("_primary_type" "abstract_class_declaration" "abstract_method_signature" "accessibility_modifier" "ambient_declaration" "arguments" "array" "array_pattern" "array_type" "arrow_function" "as_expression" "asserts" "asserts_annotation" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "call_signature" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "conditional_type" "constraint" "construct_signature" "constructor_type" "continue_statement" "debugger_statement" "declaration" "decorator" "default_type" "do_statement" "else_clause" "empty_statement" "enum_assignment" "enum_body" "enum_declaration" "escape_sequence" "existential_type" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "extends_clause" "extends_type_clause" "false" "finally_clause" "flow_maybe_type" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "function_signature" "function_type" "generator_function" "generator_function_declaration" "generic_type" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "implements_clause" "import" "import_alias" "import_clause" "import_require_clause" "import_specifier" "import_statement" "index_signature" "index_type_query" "infer_type" "instantiation_expression" "interface_declaration" "internal_module" "intersection_type" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "literal_type" "lookup_type" "mapped_type_clause" "member_expression" "meta_property" "method_definition" "method_signature" "module" "named_imports" "namespace_export" "namespace_import" "nested_identifier" "nested_type_identifier" "new_expression" "non_null_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "object_type" "omitting_type_annotation" "opting_type_annotation" "optional_chain" "optional_parameter" "optional_type" "override_modifier" "pair" "pair_pattern" "parenthesized_expression" "parenthesized_type" "pattern" "predefined_type" "primary_expression" "private_property_identifier" "program" "property_identifier" "property_signature" "public_field_definition" "readonly_type" "regex" "regex_flags" "regex_pattern" "required_parameter" "rest_pattern" "rest_type" "return_statement" "satisfies_expression" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_literal_type" "template_string" "template_substitution" "template_type" "ternary_expression" "this" "this_type" "throw_statement" "true" "try_statement" "tuple_type" "type_alias_declaration" "type_annotation" "type_arguments" "type_identifier" "type_parameter" "type_parameters" "type_predicate" "type_predicate_annotation" "type_query" "unary_expression" "undefined" "union_type" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression")
)
;; END All node types in tsx
;; START All supertypes in tsx
(defconst combobulate-rules-tsx-supertypes
 '("_primary_type" "declaration" "expression" "pattern" "primary_expression" "statement")
)
;; END All supertypes in tsx

;; START Production rules for css
(defconst combobulate-rules-css
 '(("adjacent_sibling_selector" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("arguments" (:*unnamed* ("float_value" "plain_value" "tag_name" "child_selector" "nesting_selector" "id_selector" "descendant_selector" "string_value" "color_value" "binary_expression" "class_selector" "parenthesized_value" "universal_selector" "important" "adjacent_sibling_selector" "sibling_selector" "integer_value" "attribute_selector" "pseudo_class_selector" "pseudo_element_selector" "call_expression" "grid_value" "namespace_selector")))
 ("at_keyword" (:*unnamed* nil))
 ("at_rule" (:*unnamed* ("at_keyword" "parenthesized_query" "unary_query" "keyword_query" "selector_query" "block" "binary_query" "feature_query")))
 ("attribute_name" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("attribute_selector" (:*unnamed* ("float_value" "plain_value" "tag_name" "child_selector" "nesting_selector" "id_selector" "descendant_selector" "string_value" "color_value" "binary_expression" "class_selector" "parenthesized_value" "universal_selector" "important" "namespace_selector" "adjacent_sibling_selector" "sibling_selector" "integer_value" "attribute_selector" "pseudo_class_selector" "pseudo_element_selector" "call_expression" "grid_value" "attribute_name")))
 ("binary_expression" (:*unnamed* ("float_value" "color_value" "plain_value" "binary_expression" "parenthesized_value" "important" "integer_value" "call_expression" "grid_value" "string_value")))
 ("binary_query" (:*unnamed* ("parenthesized_query" "unary_query" "keyword_query" "feature_query" "binary_query" "selector_query")))
 ("block" (:*unnamed* ("at_rule" "import_statement" "namespace_statement" "postcss_statement" "supports_statement" "rule_set" "keyframes_statement" "declaration" "charset_statement" "media_statement")))
 ("call_expression" (:*unnamed* ("arguments" "function_name")))
 ("charset_statement" (:*unnamed* ("float_value" "color_value" "plain_value" "binary_expression" "parenthesized_value" "important" "integer_value" "call_expression" "grid_value" "string_value")))
 ("child_selector" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("class_name" (:*unnamed* nil))
 ("class_selector" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "class_name" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("color_value" (:*unnamed* nil))
 ("comment" (:*unnamed* nil))
 ("declaration" (:*unnamed* ("float_value" "color_value" "plain_value" "binary_expression" "property_name" "parenthesized_value" "important" "integer_value" "call_expression" "grid_value" "string_value")))
 ("descendant_selector" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("feature_name" (:*unnamed* nil))
 ("feature_query" (:*unnamed* ("float_value" "color_value" "plain_value" "binary_expression" "parenthesized_value" "important" "feature_name" "integer_value" "call_expression" "grid_value" "string_value")))
 ("float_value" (:*unnamed* ("unit")))
 ("from" (:*unnamed* nil))
 ("function_name" (:*unnamed* nil))
 ("grid_value" (:*unnamed* ("float_value" "color_value" "plain_value" "binary_expression" "parenthesized_value" "important" "integer_value" "call_expression" "grid_value" "string_value")))
 ("id_name" (:*unnamed* nil))
 ("id_selector" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_name" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("import_statement" (:*unnamed* ("float_value" "plain_value" "unary_query" "keyword_query" "binary_query" "feature_query" "string_value" "color_value" "parenthesized_query" "binary_expression" "parenthesized_value" "important" "selector_query" "integer_value" "call_expression" "grid_value")))
 ("important" (:*unnamed* nil))
 ("integer_value" (:*unnamed* ("unit")))
 ("js_comment" (:*unnamed* nil))
 ("keyframe_block" (:*unnamed* ("integer_value" "to" "block" "from")))
 ("keyframe_block_list" (:*unnamed* ("keyframe_block")))
 ("keyframes_name" (:*unnamed* nil))
 ("keyframes_statement" (:*unnamed* ("at_keyword" "keyframes_name" "keyframe_block_list")))
 ("keyword_query" (:*unnamed* nil))
 ("media_statement" (:*unnamed* ("parenthesized_query" "block" "unary_query" "keyword_query" "feature_query" "binary_query" "selector_query")))
 ("namespace_name" (:*unnamed* nil))
 ("namespace_selector" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("namespace_statement" (:*unnamed* ("string_value" "call_expression" "namespace_name")))
 ("nesting_selector" (:*unnamed* nil))
 ("parenthesized_query" (:*unnamed* ("parenthesized_query" "unary_query" "keyword_query" "feature_query" "binary_query" "selector_query")))
 ("parenthesized_value" (:*unnamed* ("float_value" "color_value" "plain_value" "binary_expression" "parenthesized_value" "important" "integer_value" "call_expression" "grid_value" "string_value")))
 ("plain_value" (:*unnamed* nil))
 ("postcss_statement" (:*unnamed* ("at_keyword" "color_value" "float_value" "plain_value" "binary_expression" "parenthesized_value" "important" "integer_value" "call_expression" "grid_value" "string_value")))
 ("property_name" (:*unnamed* nil))
 ("pseudo_class_selector" (:*unnamed* ("tag_name" "child_selector" "nesting_selector" "id_selector" "class_name" "descendant_selector" "string_value" "arguments" "class_selector" "universal_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "pseudo_class_selector" "pseudo_element_selector" "namespace_selector")))
 ("pseudo_element_selector" (:*unnamed* ("pseudo_class_selector" "arguments" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("rule_set" (:*unnamed* ("block" "selectors")))
 ("selector_query" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("selectors" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("sibling_selector" (:*unnamed* ("pseudo_class_selector" "tag_name" "class_selector" "child_selector" "universal_selector" "nesting_selector" "id_selector" "adjacent_sibling_selector" "sibling_selector" "attribute_selector" "descendant_selector" "pseudo_element_selector" "string_value" "namespace_selector")))
 ("string_value" (:*unnamed* nil))
 ("stylesheet" (:*unnamed* ("at_rule" "import_statement" "namespace_statement" "supports_statement" "rule_set" "keyframes_statement" "declaration" "charset_statement" "media_statement")))
 ("supports_statement" (:*unnamed* ("parenthesized_query" "block" "unary_query" "keyword_query" "feature_query" "binary_query" "selector_query")))
 ("tag_name" (:*unnamed* nil))
 ("to" (:*unnamed* nil))
 ("unary_query" (:*unnamed* ("parenthesized_query" "unary_query" "keyword_query" "feature_query" "binary_query" "selector_query")))
 ("unit" (:*unnamed* nil))
 ("universal_selector" (:*unnamed* nil))
))
;; END Production rules for css
;; START Inverse production rules for css
(defconst combobulate-rules-css-inverse
 '(("adjacent_sibling_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("arguments" ("pseudo_class_selector" "pseudo_element_selector" "call_expression"))
   ("at_keyword" ("postcss_statement" "at_rule" "keyframes_statement"))
   ("at_rule" ("block" "stylesheet"))
   ("attribute_name" ("attribute_selector"))
   ("attribute_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("binary_expression" ("arguments" "binary_expression" "import_statement" "postcss_statement" "parenthesized_value" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("binary_query" ("at_rule" "parenthesized_query" "import_statement" "unary_query" "supports_statement" "binary_query" "media_statement"))
   ("block" ("at_rule" "supports_statement" "rule_set" "keyframe_block" "media_statement"))
   ("call_expression" ("arguments" "binary_expression" "import_statement" "namespace_statement" "parenthesized_value" "postcss_statement" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("charset_statement" ("block" "stylesheet"))
   ("child_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("class_name" ("class_selector" "pseudo_class_selector"))
   ("class_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("color_value" ("arguments" "binary_expression" "import_statement" "postcss_statement" "parenthesized_value" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("declaration" ("block" "stylesheet"))
   ("descendant_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("feature_name" ("feature_query"))
   ("feature_query" ("at_rule" "parenthesized_query" "import_statement" "unary_query" "supports_statement" "binary_query" "media_statement"))
   ("float_value" ("arguments" "binary_expression" "import_statement" "postcss_statement" "parenthesized_value" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("from" ("keyframe_block"))
   ("function_name" ("call_expression"))
   ("grid_value" ("arguments" "binary_expression" "import_statement" "postcss_statement" "parenthesized_value" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("id_name" ("id_selector"))
   ("id_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("import_statement" ("block" "stylesheet"))
   ("important" ("arguments" "binary_expression" "import_statement" "postcss_statement" "parenthesized_value" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("integer_value" ("arguments" "binary_expression" "import_statement" "keyframe_block" "postcss_statement" "parenthesized_value" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("keyframe_block" ("keyframe_block_list"))
   ("keyframe_block_list" ("keyframes_statement"))
   ("keyframes_name" ("keyframes_statement"))
   ("keyframes_statement" ("block" "stylesheet"))
   ("keyword_query" ("at_rule" "parenthesized_query" "import_statement" "unary_query" "supports_statement" "binary_query" "media_statement"))
   ("media_statement" ("block" "stylesheet"))
   ("namespace_name" ("namespace_statement"))
   ("namespace_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("namespace_statement" ("block" "stylesheet"))
   ("nesting_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("parenthesized_query" ("at_rule" "parenthesized_query" "import_statement" "unary_query" "supports_statement" "binary_query" "media_statement"))
   ("parenthesized_value" ("arguments" "binary_expression" "import_statement" "postcss_statement" "parenthesized_value" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("plain_value" ("arguments" "binary_expression" "import_statement" "postcss_statement" "parenthesized_value" "declaration" "attribute_selector" "feature_query" "charset_statement" "grid_value"))
   ("postcss_statement" ("block"))
   ("property_name" ("declaration"))
   ("pseudo_class_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("pseudo_element_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("rule_set" ("block" "stylesheet"))
   ("selector_query" ("at_rule" "parenthesized_query" "import_statement" "unary_query" "supports_statement" "binary_query" "media_statement"))
   ("selectors" ("rule_set"))
   ("sibling_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("string_value" ("namespace_statement" "descendant_selector" "arguments" "binary_expression" "selector_query" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "attribute_name" "import_statement" "postcss_statement" "child_selector" "id_selector" "charset_statement" "class_selector" "parenthesized_value" "declaration" "pseudo_class_selector" "pseudo_element_selector" "feature_query" "grid_value" "namespace_selector"))
   ("supports_statement" ("block" "stylesheet"))
   ("tag_name" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
   ("to" ("keyframe_block"))
   ("unary_query" ("at_rule" "parenthesized_query" "import_statement" "unary_query" "supports_statement" "binary_query" "media_statement"))
   ("unit" ("float_value" "integer_value"))
   ("universal_selector" ("pseudo_class_selector" "arguments" "class_selector" "child_selector" "namespace_selector" "selector_query" "id_selector" "adjacent_sibling_selector" "sibling_selector" "selectors" "attribute_selector" "descendant_selector" "pseudo_element_selector" "attribute_name"))
  )
)
;; END Inverse production rules for css
;; START All node types in css
(defconst combobulate-rules-css-types
 '("adjacent_sibling_selector" "arguments" "at_keyword" "at_rule" "attribute_name" "attribute_selector" "binary_expression" "binary_query" "block" "call_expression" "charset_statement" "child_selector" "class_name" "class_selector" "color_value" "comment" "declaration" "descendant_selector" "feature_name" "feature_query" "float_value" "from" "function_name" "grid_value" "id_name" "id_selector" "import_statement" "important" "integer_value" "js_comment" "keyframe_block" "keyframe_block_list" "keyframes_name" "keyframes_statement" "keyword_query" "media_statement" "namespace_name" "namespace_selector" "namespace_statement" "nesting_selector" "parenthesized_query" "parenthesized_value" "plain_value" "postcss_statement" "property_name" "pseudo_class_selector" "pseudo_element_selector" "rule_set" "selector_query" "selectors" "sibling_selector" "string_value" "stylesheet" "supports_statement" "tag_name" "to" "unary_query" "unit" "universal_selector")
)
;; END All node types in css
;; START All supertypes in css
(defconst combobulate-rules-css-supertypes
 nil
)
;; END All supertypes in css

;; START Production rules for typescript
(defconst combobulate-rules-typescript
 '(("_primary_type" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query")))
 ("abstract_class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
 ("abstract_method_signature" (:*unnamed* ("accessibility_modifier") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("accessibility_modifier" (:*unnamed* nil))
 ("ambient_declaration" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "property_identifier" "existential_type" "declaration" "readonly_type" "statement_block" "type_query" "infer_type")))
 ("arguments" (:*unnamed* ("spread_element" "expression")))
 ("array" (:*unnamed* ("spread_element" "expression")))
 ("array_pattern" (:*unnamed* ("pattern" "assignment_pattern")))
 ("array_type" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query")))
 ("arrow_function" (:*unnamed* nil :body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("as_expression" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "expression" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("asserts" (:*unnamed* ("identifier" "type_predicate" "this")))
 ("asserts_annotation" (:*unnamed* ("asserts")))
 ("assignment_expression" (:*unnamed* nil :left ("member_expression" "object_pattern" "subscript_expression" "non_null_expression" "array_pattern" "identifier" "undefined" "parenthesized_expression") :right ("expression")))
 ("assignment_pattern" (:*unnamed* nil :left ("pattern") :right ("expression")))
 ("augmented_assignment_expression" (:*unnamed* nil :left ("identifier" "member_expression" "subscript_expression" "non_null_expression" "parenthesized_expression") :operator nil :right ("expression")))
 ("await_expression" (:*unnamed* ("expression")))
 ("binary_expression" (:*unnamed* nil :left ("expression") :operator nil :right ("expression")))
 ("break_statement" (:*unnamed* nil :label ("statement_identifier")))
 ("call_expression" (:*unnamed* nil :arguments ("arguments" "template_string") :function ("expression") :type_arguments ("type_arguments")))
 ("call_signature" (:*unnamed* nil :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("catch_clause" (:*unnamed* nil :body ("statement_block") :parameter ("identifier" "object_pattern" "array_pattern") :type ("type_annotation")))
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
 ("class_body" (:*unnamed* ("class_static_block" "method_definition" "abstract_method_signature" "decorator" "index_signature" "method_signature" "public_field_definition")))
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
 ("class_heritage" (:*unnamed* ("implements_clause" "extends_clause")))
 ("class_static_block" (:*unnamed* nil :body ("statement_block")))
 ("comment" (:*unnamed* nil))
 ("computed_property_name" (:*unnamed* ("expression")))
 ("conditional_type" (:*unnamed* nil :alternative ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :consequence ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :left ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :right ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("constraint" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("construct_signature" (:*unnamed* nil :parameters ("formal_parameters") :type ("type_annotation") :type_parameters ("type_parameters")))
 ("constructor_type" (:*unnamed* nil :parameters ("formal_parameters") :type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :type_parameters ("type_parameters")))
 ("continue_statement" (:*unnamed* nil :label ("statement_identifier")))
 ("debugger_statement" (:*unnamed* nil))
 ("declaration" (:*unnamed* ("interface_declaration" "variable_declaration" "import_alias" "lexical_declaration" "module" "generator_function_declaration" "ambient_declaration" "enum_declaration" "class_declaration" "type_alias_declaration" "function_signature" "function_declaration" "internal_module" "abstract_class_declaration")))
 ("decorator" (:*unnamed* ("identifier" "member_expression" "call_expression")))
 ("default_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("do_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression")))
 ("else_clause" (:*unnamed* ("statement")))
 ("empty_statement" (:*unnamed* nil))
 ("enum_assignment" (:*unnamed* nil :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("expression")))
 ("enum_body" (:*unnamed* ("enum_assignment") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier")))
 ("enum_declaration" (:*unnamed* nil :body ("enum_body") :name ("identifier")))
 ("escape_sequence" (:*unnamed* nil))
 ("existential_type" (:*unnamed* nil))
 ("export_clause" (:*unnamed* ("export_specifier")))
 ("export_specifier" (:*unnamed* nil :alias ("identifier" "string") :name ("identifier" "string")))
 ("export_statement" (:*unnamed* ("identifier" "namespace_export" "export_clause" "expression") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression")))
 ("expression" (:*unnamed* ("augmented_assignment_expression" "ternary_expression" "type_assertion" "instantiation_expression" "unary_expression" "internal_module" "update_expression" "glimmer_template" "satisfies_expression" "binary_expression" "await_expression" "assignment_expression" "new_expression" "primary_expression" "as_expression" "yield_expression")))
 ("expression_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("extends_clause" (:*unnamed* nil :type_arguments ("type_arguments") :value ("expression")))
 ("extends_type_clause" (:*unnamed* nil :type ("type_identifier" "generic_type" "nested_type_identifier")))
 ("false" (:*unnamed* nil))
 ("finally_clause" (:*unnamed* nil :body ("statement_block")))
 ("flow_maybe_type" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query")))
 ("for_in_statement" (:*unnamed* nil :body ("statement") :kind nil :left ("member_expression" "object_pattern" "subscript_expression" "non_null_expression" "array_pattern" "identifier" "undefined" "parenthesized_expression") :operator nil :right ("sequence_expression" "expression") :value ("expression")))
 ("for_statement" (:*unnamed* nil :body ("statement") :condition ("expression_statement" "empty_statement") :increment ("sequence_expression" "expression") :initializer ("expression_statement" "lexical_declaration" "empty_statement" "variable_declaration")))
 ("formal_parameters" (:*unnamed* ("optional_parameter" "required_parameter")))
 ("function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("function_signature" (:*unnamed* nil :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("function_type" (:*unnamed* nil :parameters ("formal_parameters") :return_type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "asserts" "flow_maybe_type" "type_predicate" "existential_type" "readonly_type" "type_query" "infer_type") :type_parameters ("type_parameters")))
 ("generator_function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("generator_function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("generic_type" (:*unnamed* nil :name ("type_identifier" "nested_type_identifier") :type_arguments ("type_arguments")))
 ("glimmer_closing_tag" (:*unnamed* nil))
 ("glimmer_opening_tag" (:*unnamed* nil))
 ("glimmer_template" (:*unnamed* nil :close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag")))
 ("hash_bang_line" (:*unnamed* nil))
 ("identifier" (:*unnamed* nil))
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement")))
 ("implements_clause" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("import" (:*unnamed* nil))
 ("import_alias" (:*unnamed* ("identifier" "nested_identifier")))
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports")))
 ("import_require_clause" (:*unnamed* ("identifier") :source ("string")))
 ("import_specifier" (:*unnamed* nil :alias ("identifier") :name ("identifier" "string")))
 ("import_statement" (:*unnamed* ("import_require_clause" "import_clause") :source ("string")))
 ("index_signature" (:*unnamed* ("mapped_type_clause") :index_type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :name ("identifier") :sign nil :type ("opting_type_annotation" "type_annotation" "omitting_type_annotation")))
 ("index_type_query" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query")))
 ("infer_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("instantiation_expression" (:*unnamed* ("expression") :function ("identifier" "subscript_expression" "import" "member_expression") :type_arguments ("type_arguments")))
 ("interface_declaration" (:*unnamed* ("extends_type_clause") :body ("object_type") :name ("type_identifier") :type_parameters ("type_parameters")))
 ("internal_module" (:*unnamed* nil :body ("statement_block") :name ("identifier" "string" "nested_identifier")))
 ("intersection_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("jsx_attribute" (:*unnamed* ("property_identifier" "jsx_element" "jsx_namespace_name" "jsx_self_closing_element" "string" "jsx_expression")))
 ("jsx_closing_element" (:*unnamed* nil :name ("identifier" "member_expression" "jsx_namespace_name")))
 ("jsx_element" (:*unnamed* ("jsx_element" "jsx_text" "jsx_expression" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element")))
 ("jsx_expression" (:*unnamed* ("sequence_expression" "spread_element" "expression")))
 ("jsx_namespace_name" (:*unnamed* ("identifier")))
 ("jsx_opening_element" (:*unnamed* nil :attribute ("jsx_expression" "jsx_attribute") :name ("identifier" "member_expression" "jsx_namespace_name") :type_arguments ("type_arguments")))
 ("jsx_self_closing_element" (:*unnamed* nil :attribute ("jsx_expression" "jsx_attribute") :name ("identifier" "member_expression" "jsx_namespace_name") :type_arguments ("type_arguments")))
 ("jsx_text" (:*unnamed* nil))
 ("labeled_statement" (:*unnamed* nil :body ("statement") :label ("statement_identifier")))
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil))
 ("literal_type" (:*unnamed* ("null" "undefined" "unary_expression" "false" "string" "number" "true")))
 ("lookup_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("mapped_type_clause" (:*unnamed* nil :alias ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type") :name ("type_identifier") :type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("member_expression" (:*unnamed* ("identifier" "property_identifier" "member_expression") :object ("expression") :optional_chain ("optional_chain") :property ("property_identifier" "private_property_identifier")))
 ("meta_property" (:*unnamed* nil))
 ("method_definition" (:*unnamed* ("override_modifier" "accessibility_modifier") :body ("statement_block") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("method_signature" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :parameters ("formal_parameters") :return_type ("asserts_annotation" "type_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
 ("module" (:*unnamed* nil :body ("statement_block") :name ("identifier" "string" "nested_identifier")))
 ("named_imports" (:*unnamed* ("import_specifier")))
 ("namespace_export" (:*unnamed* ("identifier" "string")))
 ("namespace_import" (:*unnamed* ("identifier")))
 ("nested_identifier" (:*unnamed* ("identifier" "property_identifier" "member_expression")))
 ("nested_type_identifier" (:*unnamed* nil :module ("identifier" "nested_identifier") :name ("type_identifier")))
 ("new_expression" (:*unnamed* nil :arguments ("arguments") :constructor ("primary_expression") :type_arguments ("type_arguments")))
 ("non_null_expression" (:*unnamed* ("expression")))
 ("null" (:*unnamed* nil))
 ("number" (:*unnamed* nil))
 ("object" (:*unnamed* ("pair" "method_definition" "shorthand_property_identifier" "spread_element")))
 ("object_assignment_pattern" (:*unnamed* nil :left ("object_pattern" "shorthand_property_identifier_pattern" "array_pattern") :right ("expression")))
 ("object_pattern" (:*unnamed* ("pair_pattern" "shorthand_property_identifier_pattern" "object_assignment_pattern" "rest_pattern")))
 ("object_type" (:*unnamed* ("property_signature" "export_statement" "index_signature" "call_signature" "method_signature" "construct_signature")))
 ("omitting_type_annotation" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("opting_type_annotation" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("optional_chain" (:*unnamed* nil))
 ("optional_parameter" (:*unnamed* ("override_modifier" "accessibility_modifier") :decorator ("decorator") :name ("identifier") :pattern ("pattern" "this") :type ("type_annotation") :value ("expression")))
 ("optional_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("override_modifier" (:*unnamed* nil))
 ("pair" (:*unnamed* nil :key ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("expression")))
 ("pair_pattern" (:*unnamed* nil :key ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("pattern" "assignment_pattern")))
 ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression") :type ("type_annotation")))
 ("parenthesized_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("pattern" (:*unnamed* ("member_expression" "object_pattern" "subscript_expression" "non_null_expression" "array_pattern" "identifier" "undefined" "rest_pattern")))
 ("predefined_type" (:*unnamed* nil))
 ("primary_expression" (:*unnamed* ("arrow_function" "meta_property" "regex" "member_expression" "false" "generator_function" "string" "subscript_expression" "non_null_expression" "true" "null" "this" "object" "class" "template_string" "array" "super" "import" "number" "identifier" "undefined" "function" "call_expression" "parenthesized_expression")))
 ("private_property_identifier" (:*unnamed* nil))
 ("program" (:*unnamed* ("statement" "hash_bang_line")))
 ("property_identifier" (:*unnamed* nil))
 ("property_signature" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :type ("type_annotation")))
 ("public_field_definition" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :type ("type_annotation") :value ("expression")))
 ("readonly_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("regex" (:*unnamed* nil :flags ("regex_flags") :pattern ("regex_pattern")))
 ("regex_flags" (:*unnamed* nil))
 ("regex_pattern" (:*unnamed* nil))
 ("required_parameter" (:*unnamed* ("override_modifier" "accessibility_modifier") :decorator ("decorator") :name ("identifier" "rest_pattern") :pattern ("pattern" "this") :type ("type_annotation") :value ("expression")))
 ("rest_pattern" (:*unnamed* ("identifier" "undefined" "member_expression" "object_pattern" "subscript_expression" "non_null_expression" "array_pattern")))
 ("rest_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("return_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("satisfies_expression" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "expression" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("sequence_expression" (:*unnamed* nil :left ("expression") :right ("sequence_expression" "expression")))
 ("shorthand_property_identifier" (:*unnamed* nil))
 ("shorthand_property_identifier_pattern" (:*unnamed* nil))
 ("spread_element" (:*unnamed* ("expression")))
 ("statement" (:*unnamed* ("import_statement" "expression_statement" "return_statement" "labeled_statement" "continue_statement" "throw_statement" "debugger_statement" "break_statement" "if_statement" "try_statement" "do_statement" "empty_statement" "while_statement" "declaration" "for_statement" "statement_block" "with_statement" "for_in_statement" "export_statement" "switch_statement")))
 ("statement_block" (:*unnamed* ("statement")))
 ("statement_identifier" (:*unnamed* nil))
 ("string" (:*unnamed* ("escape_sequence" "string_fragment")))
 ("string_fragment" (:*unnamed* nil))
 ("subscript_expression" (:*unnamed* nil :index ("predefined_type" "sequence_expression" "expression" "string" "number") :object ("expression") :optional_chain ("optional_chain")))
 ("super" (:*unnamed* nil))
 ("switch_body" (:*unnamed* ("switch_case" "switch_default")))
 ("switch_case" (:*unnamed* nil :body ("statement") :value ("sequence_expression" "expression")))
 ("switch_default" (:*unnamed* nil :body ("statement")))
 ("switch_statement" (:*unnamed* nil :body ("switch_body") :value ("parenthesized_expression")))
 ("template_literal_type" (:*unnamed* ("template_type")))
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution")))
 ("template_substitution" (:*unnamed* ("sequence_expression" "expression")))
 ("template_type" (:*unnamed* ("intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "type_query" "infer_type")))
 ("ternary_expression" (:*unnamed* nil :alternative ("expression") :condition ("expression") :consequence ("expression")))
 ("this" (:*unnamed* nil))
 ("this_type" (:*unnamed* nil))
 ("throw_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("true" (:*unnamed* nil))
 ("try_statement" (:*unnamed* nil :body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause")))
 ("tuple_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "optional_type" "array_type" "predefined_type" "optional_parameter" "template_literal_type" "required_parameter" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "rest_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_alias_declaration" (:*unnamed* nil :name ("type_identifier") :type_parameters ("type_parameters") :value ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_annotation" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_arguments" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_assertion" (:*unnamed* ("type_arguments" "expression")))
 ("type_identifier" (:*unnamed* nil))
 ("type_parameter" (:*unnamed* nil :constraint ("constraint") :name ("type_identifier") :value ("default_type")))
 ("type_parameters" (:*unnamed* ("type_parameter")))
 ("type_predicate" (:*unnamed* nil :name ("identifier" "this") :type ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("type_predicate_annotation" (:*unnamed* ("type_predicate")))
 ("type_query" (:*unnamed* ("identifier" "instantiation_expression" "member_expression" "subscript_expression" "call_expression")))
 ("unary_expression" (:*unnamed* nil :argument ("number" "expression") :operator nil))
 ("undefined" (:*unnamed* nil))
 ("union_type" (:*unnamed* ("function_type" "intersection_type" "tuple_type" "literal_type" "conditional_type" "generic_type" "index_type_query" "array_type" "predefined_type" "template_literal_type" "this_type" "type_identifier" "object_type" "parenthesized_type" "constructor_type" "lookup_type" "nested_type_identifier" "union_type" "flow_maybe_type" "existential_type" "readonly_type" "type_query" "infer_type")))
 ("update_expression" (:*unnamed* nil :argument ("expression") :operator nil))
 ("variable_declaration" (:*unnamed* ("variable_declarator")))
 ("variable_declarator" (:*unnamed* nil :name ("identifier" "object_pattern" "array_pattern") :type ("type_annotation") :value ("expression")))
 ("while_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression")))
 ("with_statement" (:*unnamed* nil :body ("statement") :object ("parenthesized_expression")))
 ("yield_expression" (:*unnamed* ("expression")))
))
;; END Production rules for typescript
;; START Inverse production rules for typescript
(defconst combobulate-rules-typescript-inverse
 '(("abstract_class_declaration" ("declaration"))
   ("abstract_method_signature" ("class_body"))
   ("accessibility_modifier" ("method_definition" "abstract_method_signature" "public_field_definition" "property_signature" "optional_parameter" "required_parameter" "method_signature"))
   ("ambient_declaration" ("declaration"))
   ("arguments" ("new_expression" "call_expression"))
   ("array" ("primary_expression"))
   ("array_pattern" ("pattern" "object_assignment_pattern" "assignment_expression" "catch_clause" "rest_pattern" "for_in_statement" "variable_declarator"))
   ("array_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("arrow_function" ("primary_expression"))
   ("as_expression" ("expression"))
   ("asserts" ("asserts_annotation" "function_type"))
   ("asserts_annotation" ("arrow_function" "method_definition" "abstract_method_signature" "function" "generator_function" "call_signature" "generator_function_declaration" "function_signature" "function_declaration" "method_signature"))
   ("assignment_expression" ("expression"))
   ("assignment_pattern" ("pair_pattern" "array_pattern"))
   ("augmented_assignment_expression" ("expression"))
   ("await_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("break_statement" ("statement"))
   ("call_expression" ("primary_expression" "type_query" "decorator"))
   ("call_signature" ("object_type"))
   ("catch_clause" ("try_statement"))
   ("class" ("primary_expression"))
   ("class_body" ("class_declaration" "class" "abstract_class_declaration"))
   ("class_declaration" ("declaration"))
   ("class_heritage" ("class_declaration" "class" "abstract_class_declaration"))
   ("class_static_block" ("class_body"))
   ("computed_property_name" ("pair" "method_definition" "abstract_method_signature" "enum_body" "public_field_definition" "property_signature" "enum_assignment" "pair_pattern" "method_signature"))
   ("conditional_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("constraint" ("type_parameter"))
   ("construct_signature" ("object_type"))
   ("constructor_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "as_expression"))
   ("continue_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("ambient_declaration" "statement" "export_statement"))
   ("decorator" ("required_parameter" "class_body" "optional_parameter" "abstract_class_declaration" "class_declaration" "class" "export_statement"))
   ("default_type" ("type_parameter"))
   ("do_statement" ("statement"))
   ("else_clause" ("if_statement"))
   ("empty_statement" ("for_statement" "statement"))
   ("enum_assignment" ("enum_body"))
   ("enum_body" ("enum_declaration"))
   ("enum_declaration" ("declaration"))
   ("escape_sequence" ("string" "template_string"))
   ("existential_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("export_clause" ("export_statement"))
   ("export_specifier" ("export_clause"))
   ("export_statement" ("object_type" "statement"))
   ("expression" ("arrow_function" "computed_property_name" "member_expression" "augmented_assignment_expression" "ternary_expression" "optional_parameter" "instantiation_expression" "template_substitution" "unary_expression" "throw_statement" "required_parameter" "update_expression" "pair" "arguments" "binary_expression" "for_statement" "for_in_statement" "array" "export_statement" "yield_expression" "expression_statement" "subscript_expression" "non_null_expression" "public_field_definition" "return_statement" "type_assertion" "sequence_expression" "extends_clause" "switch_case" "assignment_pattern" "variable_declarator" "satisfies_expression" "await_expression" "object_assignment_pattern" "jsx_expression" "assignment_expression" "enum_assignment" "spread_element" "as_expression" "call_expression" "parenthesized_expression"))
   ("expression_statement" ("for_statement" "statement"))
   ("extends_clause" ("class_heritage"))
   ("extends_type_clause" ("interface_declaration"))
   ("false" ("primary_expression" "literal_type"))
   ("finally_clause" ("try_statement"))
   ("flow_maybe_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("for_in_statement" ("statement"))
   ("for_statement" ("statement"))
   ("formal_parameters" ("arrow_function" "function_type" "abstract_method_signature" "constructor_type" "method_definition" "method_signature" "generator_function" "call_signature" "generator_function_declaration" "function_signature" "function" "function_declaration" "construct_signature"))
   ("function" ("primary_expression"))
   ("function_declaration" ("declaration"))
   ("function_signature" ("declaration"))
   ("function_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "as_expression"))
   ("generator_function" ("primary_expression"))
   ("generator_function_declaration" ("declaration"))
   ("generic_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "extends_type_clause" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("glimmer_template" ("expression"))
   ("hash_bang_line" ("program"))
   ("identifier" ("arrow_function" "jsx_closing_element" "namespace_import" "member_expression" "augmented_assignment_expression" "index_signature" "optional_parameter" "instantiation_expression" "rest_pattern" "function_declaration" "internal_module" "required_parameter" "import_alias" "decorator" "asserts" "module" "generator_function_declaration" "enum_declaration" "import_specifier" "nested_identifier" "function" "for_in_statement" "export_statement" "import_clause" "jsx_self_closing_element" "function_signature" "export_specifier" "variable_declarator" "import_require_clause" "pattern" "nested_type_identifier" "namespace_export" "assignment_expression" "catch_clause" "type_predicate" "jsx_namespace_name" "jsx_opening_element" "primary_expression" "type_query" "generator_function"))
   ("if_statement" ("statement"))
   ("implements_clause" ("class_heritage"))
   ("import" ("primary_expression" "instantiation_expression"))
   ("import_alias" ("declaration"))
   ("import_clause" ("import_statement"))
   ("import_require_clause" ("import_statement"))
   ("import_specifier" ("named_imports"))
   ("import_statement" ("statement"))
   ("index_signature" ("object_type" "class_body"))
   ("index_type_query" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("infer_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "as_expression"))
   ("instantiation_expression" ("type_query" "expression"))
   ("interface_declaration" ("declaration"))
   ("internal_module" ("declaration" "expression"))
   ("intersection_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_element" ("jsx_element" "jsx_attribute"))
   ("jsx_expression" ("jsx_self_closing_element" "jsx_element" "jsx_opening_element" "jsx_attribute"))
   ("jsx_namespace_name" ("jsx_closing_element" "jsx_self_closing_element" "jsx_opening_element" "jsx_attribute"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_self_closing_element" ("jsx_element" "jsx_attribute"))
   ("jsx_text" ("jsx_element"))
   ("labeled_statement" ("statement"))
   ("lexical_declaration" ("for_statement" "declaration"))
   ("literal_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("lookup_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("mapped_type_clause" ("index_signature"))
   ("member_expression" ("jsx_closing_element" "pattern" "augmented_assignment_expression" "member_expression" "nested_identifier" "decorator" "rest_pattern" "assignment_expression" "instantiation_expression" "jsx_opening_element" "jsx_self_closing_element" "primary_expression" "type_query" "for_in_statement"))
   ("meta_property" ("primary_expression"))
   ("method_definition" ("object" "class_body"))
   ("method_signature" ("object_type" "class_body"))
   ("module" ("declaration"))
   ("named_imports" ("import_clause"))
   ("namespace_export" ("export_statement"))
   ("namespace_import" ("import_clause"))
   ("nested_identifier" ("module" "internal_module" "nested_type_identifier" "import_alias"))
   ("nested_type_identifier" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "generic_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "extends_type_clause" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("new_expression" ("expression"))
   ("non_null_expression" ("pattern" "augmented_assignment_expression" "rest_pattern" "assignment_expression" "primary_expression" "for_in_statement"))
   ("null" ("primary_expression" "literal_type"))
   ("number" ("pair" "method_definition" "abstract_method_signature" "pair_pattern" "literal_type" "subscript_expression" "enum_body" "public_field_definition" "property_signature" "enum_assignment" "unary_expression" "primary_expression" "method_signature"))
   ("object" ("primary_expression"))
   ("object_assignment_pattern" ("object_pattern"))
   ("object_pattern" ("pattern" "object_assignment_pattern" "assignment_expression" "catch_clause" "rest_pattern" "for_in_statement" "variable_declarator"))
   ("object_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "interface_declaration" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("omitting_type_annotation" ("index_signature"))
   ("opting_type_annotation" ("index_signature"))
   ("optional_chain" ("subscript_expression" "member_expression"))
   ("optional_parameter" ("formal_parameters" "tuple_type"))
   ("optional_type" ("tuple_type"))
   ("override_modifier" ("method_definition" "public_field_definition" "property_signature" "optional_parameter" "required_parameter" "method_signature"))
   ("pair" ("object"))
   ("pair_pattern" ("object_pattern"))
   ("parenthesized_expression" ("if_statement" "augmented_assignment_expression" "assignment_expression" "do_statement" "while_statement" "primary_expression" "with_statement" "for_in_statement" "switch_statement"))
   ("parenthesized_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("pattern" ("array_pattern" "optional_parameter" "pair_pattern" "required_parameter" "assignment_pattern"))
   ("predefined_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "subscript_expression" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("primary_expression" ("new_expression" "expression"))
   ("private_property_identifier" ("pair" "method_definition" "abstract_method_signature" "member_expression" "enum_body" "public_field_definition" "property_signature" "enum_assignment" "pair_pattern" "method_signature"))
   ("property_identifier" ("pair" "method_definition" "abstract_method_signature" "member_expression" "enum_body" "public_field_definition" "ambient_declaration" "property_signature" "enum_assignment" "nested_identifier" "pair_pattern" "method_signature" "jsx_attribute"))
   ("property_signature" ("object_type"))
   ("public_field_definition" ("class_body"))
   ("readonly_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "as_expression"))
   ("regex" ("primary_expression"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("required_parameter" ("formal_parameters" "tuple_type"))
   ("rest_pattern" ("object_pattern" "pattern" "required_parameter"))
   ("rest_type" ("tuple_type"))
   ("return_statement" ("statement"))
   ("satisfies_expression" ("expression"))
   ("sequence_expression" ("expression_statement" "subscript_expression" "jsx_expression" "return_statement" "sequence_expression" "switch_case" "template_substitution" "for_statement" "throw_statement" "for_in_statement" "parenthesized_expression"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_pattern" "object_assignment_pattern"))
   ("spread_element" ("object" "arguments" "jsx_expression" "array"))
   ("statement" ("if_statement" "else_clause" "do_statement" "program" "switch_case" "statement_block" "switch_default" "for_statement" "while_statement" "with_statement" "for_in_statement" "labeled_statement"))
   ("statement_block" ("arrow_function" "class_static_block" "method_definition" "try_statement" "generator_function" "finally_clause" "internal_module" "module" "generator_function_declaration" "ambient_declaration" "statement" "catch_clause" "function" "function_declaration"))
   ("statement_identifier" ("break_statement" "continue_statement" "labeled_statement"))
   ("string" ("literal_type" "enum_body" "property_signature" "internal_module" "pair" "module" "import_specifier" "export_statement" "method_definition" "import_statement" "subscript_expression" "public_field_definition" "pair_pattern" "method_signature" "export_specifier" "jsx_attribute" "abstract_method_signature" "import_require_clause" "namespace_export" "enum_assignment" "primary_expression"))
   ("string_fragment" ("string"))
   ("subscript_expression" ("pattern" "augmented_assignment_expression" "rest_pattern" "assignment_expression" "instantiation_expression" "primary_expression" "type_query" "for_in_statement"))
   ("super" ("primary_expression"))
   ("switch_body" ("switch_statement"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_statement" ("statement"))
   ("template_literal_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("template_string" ("primary_expression" "call_expression"))
   ("template_substitution" ("template_string"))
   ("template_type" ("template_literal_type"))
   ("ternary_expression" ("expression"))
   ("this" ("asserts" "optional_parameter" "type_predicate" "primary_expression" "required_parameter"))
   ("this_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("throw_statement" ("statement"))
   ("true" ("primary_expression" "literal_type"))
   ("try_statement" ("statement"))
   ("tuple_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("type_alias_declaration" ("declaration"))
   ("type_annotation" ("arrow_function" "call_signature" "index_signature" "property_signature" "optional_parameter" "required_parameter" "function_declaration" "generator_function_declaration" "function" "method_definition" "public_field_definition" "function_signature" "method_signature" "construct_signature" "variable_declarator" "abstract_method_signature" "catch_clause" "generator_function" "parenthesized_expression"))
   ("type_arguments" ("type_assertion" "generic_type" "new_expression" "instantiation_expression" "extends_clause" "jsx_opening_element" "jsx_self_closing_element" "call_expression"))
   ("type_assertion" ("expression"))
   ("type_identifier" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_parameter" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "generic_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "class" "default_type" "parenthesized_type" "implements_clause" "interface_declaration" "lookup_type" "nested_type_identifier" "satisfies_expression" "extends_type_clause" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "class_declaration" "as_expression" "abstract_class_declaration"))
   ("type_parameter" ("type_parameters"))
   ("type_parameters" ("arrow_function" "construct_signature" "abstract_method_signature" "constructor_type" "function_type" "function" "interface_declaration" "generator_function" "method_definition" "method_signature" "call_signature" "generator_function_declaration" "class_declaration" "type_alias_declaration" "function_signature" "class" "function_declaration" "abstract_class_declaration"))
   ("type_predicate" ("function_type" "asserts" "type_predicate_annotation"))
   ("type_predicate_annotation" ("arrow_function" "method_definition" "abstract_method_signature" "function" "generator_function" "call_signature" "generator_function_declaration" "function_signature" "function_declaration" "method_signature"))
   ("type_query" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("unary_expression" ("literal_type" "expression"))
   ("undefined" ("pattern" "literal_type" "rest_pattern" "assignment_expression" "primary_expression" "for_in_statement"))
   ("union_type" ("intersection_type" "tuple_type" "index_signature" "conditional_type" "optional_type" "type_alias_declaration" "constructor_type" "flow_maybe_type" "omitting_type_annotation" "rest_type" "readonly_type" "infer_type" "opting_type_annotation" "function_type" "template_type" "index_type_query" "array_type" "mapped_type_clause" "type_arguments" "default_type" "parenthesized_type" "implements_clause" "lookup_type" "satisfies_expression" "union_type" "ambient_declaration" "constraint" "type_predicate" "type_annotation" "_primary_type" "as_expression"))
   ("update_expression" ("expression"))
   ("variable_declaration" ("for_statement" "declaration"))
   ("variable_declarator" ("lexical_declaration" "variable_declaration"))
   ("while_statement" ("statement"))
   ("with_statement" ("statement"))
   ("yield_expression" ("expression"))
  )
)
;; END Inverse production rules for typescript
;; START All node types in typescript
(defconst combobulate-rules-typescript-types
 '("_primary_type" "abstract_class_declaration" "abstract_method_signature" "accessibility_modifier" "ambient_declaration" "arguments" "array" "array_pattern" "array_type" "arrow_function" "as_expression" "asserts" "asserts_annotation" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "call_signature" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "conditional_type" "constraint" "construct_signature" "constructor_type" "continue_statement" "debugger_statement" "declaration" "decorator" "default_type" "do_statement" "else_clause" "empty_statement" "enum_assignment" "enum_body" "enum_declaration" "escape_sequence" "existential_type" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "extends_clause" "extends_type_clause" "false" "finally_clause" "flow_maybe_type" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "function_signature" "function_type" "generator_function" "generator_function_declaration" "generic_type" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "implements_clause" "import" "import_alias" "import_clause" "import_require_clause" "import_specifier" "import_statement" "index_signature" "index_type_query" "infer_type" "instantiation_expression" "interface_declaration" "internal_module" "intersection_type" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "literal_type" "lookup_type" "mapped_type_clause" "member_expression" "meta_property" "method_definition" "method_signature" "module" "named_imports" "namespace_export" "namespace_import" "nested_identifier" "nested_type_identifier" "new_expression" "non_null_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "object_type" "omitting_type_annotation" "opting_type_annotation" "optional_chain" "optional_parameter" "optional_type" "override_modifier" "pair" "pair_pattern" "parenthesized_expression" "parenthesized_type" "pattern" "predefined_type" "primary_expression" "private_property_identifier" "program" "property_identifier" "property_signature" "public_field_definition" "readonly_type" "regex" "regex_flags" "regex_pattern" "required_parameter" "rest_pattern" "rest_type" "return_statement" "satisfies_expression" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_literal_type" "template_string" "template_substitution" "template_type" "ternary_expression" "this" "this_type" "throw_statement" "true" "try_statement" "tuple_type" "type_alias_declaration" "type_annotation" "type_arguments" "type_assertion" "type_identifier" "type_parameter" "type_parameters" "type_predicate" "type_predicate_annotation" "type_query" "unary_expression" "undefined" "union_type" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression")
)
;; END All node types in typescript
;; START All supertypes in typescript
(defconst combobulate-rules-typescript-supertypes
 '("_primary_type" "declaration" "expression" "pattern" "primary_expression" "statement")
)
;; END All supertypes in typescript

;; START Production rules for javascript
(defconst combobulate-rules-javascript
 '(("arguments" (:*unnamed* ("spread_element" "expression")))
 ("array" (:*unnamed* ("spread_element" "expression")))
 ("array_pattern" (:*unnamed* ("pattern" "assignment_pattern")))
 ("arrow_function" (:*unnamed* nil :body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters")))
 ("assignment_expression" (:*unnamed* nil :left ("identifier" "undefined" "member_expression" "object_pattern" "subscript_expression" "parenthesized_expression" "array_pattern") :right ("expression")))
 ("assignment_pattern" (:*unnamed* nil :left ("pattern") :right ("expression")))
 ("augmented_assignment_expression" (:*unnamed* nil :left ("identifier" "subscript_expression" "member_expression" "parenthesized_expression") :operator nil :right ("expression")))
 ("await_expression" (:*unnamed* ("expression")))
 ("binary_expression" (:*unnamed* nil :left ("private_property_identifier" "expression") :operator nil :right ("expression")))
 ("break_statement" (:*unnamed* nil :label ("statement_identifier")))
 ("call_expression" (:*unnamed* nil :arguments ("arguments" "template_string") :function ("expression") :optional_chain ("optional_chain")))
 ("catch_clause" (:*unnamed* nil :body ("statement_block") :parameter ("identifier" "object_pattern" "array_pattern")))
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier")))
 ("class_body" (:*unnamed* nil :member ("class_static_block" "method_definition" "field_definition") :template ("glimmer_template")))
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier")))
 ("class_heritage" (:*unnamed* ("expression")))
 ("class_static_block" (:*unnamed* nil :body ("statement_block")))
 ("comment" (:*unnamed* nil))
 ("computed_property_name" (:*unnamed* ("expression")))
 ("continue_statement" (:*unnamed* nil :label ("statement_identifier")))
 ("debugger_statement" (:*unnamed* nil))
 ("declaration" (:*unnamed* ("variable_declaration" "class_declaration" "lexical_declaration" "function_declaration" "generator_function_declaration")))
 ("decorator" (:*unnamed* ("identifier" "member_expression" "call_expression")))
 ("do_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression")))
 ("else_clause" (:*unnamed* ("statement")))
 ("empty_statement" (:*unnamed* nil))
 ("escape_sequence" (:*unnamed* nil))
 ("export_clause" (:*unnamed* ("export_specifier")))
 ("export_specifier" (:*unnamed* nil :alias ("identifier" "string") :name ("identifier" "string")))
 ("export_statement" (:*unnamed* ("namespace_export" "export_clause") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression")))
 ("expression" (:*unnamed* ("augmented_assignment_expression" "binary_expression" "await_expression" "ternary_expression" "yield_expression" "assignment_expression" "new_expression" "jsx_element" "unary_expression" "jsx_self_closing_element" "primary_expression" "update_expression" "glimmer_template")))
 ("expression_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("false" (:*unnamed* nil))
 ("field_definition" (:*unnamed* nil :decorator ("decorator") :property ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("expression")))
 ("finally_clause" (:*unnamed* nil :body ("statement_block")))
 ("for_in_statement" (:*unnamed* nil :body ("statement") :kind nil :left ("identifier" "undefined" "member_expression" "object_pattern" "subscript_expression" "parenthesized_expression" "array_pattern") :operator nil :right ("sequence_expression" "expression") :value ("expression")))
 ("for_statement" (:*unnamed* nil :body ("statement") :condition ("expression_statement" "empty_statement") :increment ("sequence_expression" "expression") :initializer ("expression_statement" "lexical_declaration" "empty_statement" "variable_declaration")))
 ("formal_parameters" (:*unnamed* ("pattern" "assignment_pattern")))
 ("function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
 ("function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
 ("generator_function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
 ("generator_function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
 ("glimmer_closing_tag" (:*unnamed* nil))
 ("glimmer_opening_tag" (:*unnamed* nil))
 ("glimmer_template" (:*unnamed* nil :close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag")))
 ("hash_bang_line" (:*unnamed* nil))
 ("identifier" (:*unnamed* nil))
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement")))
 ("import" (:*unnamed* nil))
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports")))
 ("import_specifier" (:*unnamed* nil :alias ("identifier") :name ("identifier" "string")))
 ("import_statement" (:*unnamed* ("import_clause") :source ("string")))
 ("jsx_attribute" (:*unnamed* ("property_identifier" "jsx_element" "jsx_namespace_name" "jsx_self_closing_element" "string" "jsx_expression")))
 ("jsx_closing_element" (:*unnamed* nil :name ("identifier" "member_expression" "jsx_namespace_name")))
 ("jsx_element" (:*unnamed* ("jsx_element" "jsx_text" "jsx_expression" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element")))
 ("jsx_expression" (:*unnamed* ("sequence_expression" "spread_element" "expression")))
 ("jsx_namespace_name" (:*unnamed* ("identifier")))
 ("jsx_opening_element" (:*unnamed* nil :attribute ("jsx_expression" "jsx_attribute") :name ("identifier" "member_expression" "jsx_namespace_name")))
 ("jsx_self_closing_element" (:*unnamed* nil :attribute ("jsx_expression" "jsx_attribute") :name ("identifier" "member_expression" "jsx_namespace_name")))
 ("jsx_text" (:*unnamed* nil))
 ("labeled_statement" (:*unnamed* nil :body ("statement") :label ("statement_identifier")))
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil))
 ("member_expression" (:*unnamed* ("identifier" "property_identifier" "member_expression") :object ("expression") :optional_chain ("optional_chain") :property ("property_identifier" "private_property_identifier")))
 ("meta_property" (:*unnamed* nil))
 ("method_definition" (:*unnamed* nil :body ("statement_block") :decorator ("decorator") :name ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :parameters ("formal_parameters")))
 ("named_imports" (:*unnamed* ("import_specifier")))
 ("namespace_export" (:*unnamed* ("identifier" "string")))
 ("namespace_import" (:*unnamed* ("identifier")))
 ("new_expression" (:*unnamed* nil :arguments ("arguments") :constructor ("new_expression" "primary_expression")))
 ("null" (:*unnamed* nil))
 ("number" (:*unnamed* nil))
 ("object" (:*unnamed* ("pair" "method_definition" "shorthand_property_identifier" "spread_element")))
 ("object_assignment_pattern" (:*unnamed* nil :left ("object_pattern" "shorthand_property_identifier_pattern" "array_pattern") :right ("expression")))
 ("object_pattern" (:*unnamed* ("pair_pattern" "shorthand_property_identifier_pattern" "object_assignment_pattern" "rest_pattern")))
 ("optional_chain" (:*unnamed* nil))
 ("pair" (:*unnamed* nil :key ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("expression")))
 ("pair_pattern" (:*unnamed* nil :key ("property_identifier" "computed_property_name" "string" "number" "private_property_identifier") :value ("pattern" "assignment_pattern")))
 ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression")))
 ("pattern" (:*unnamed* ("identifier" "undefined" "member_expression" "object_pattern" "subscript_expression" "rest_pattern" "array_pattern")))
 ("primary_expression" (:*unnamed* ("arrow_function" "meta_property" "regex" "member_expression" "false" "generator_function" "string" "subscript_expression" "true" "null" "this" "object" "class" "template_string" "array" "super" "import" "number" "identifier" "undefined" "function" "call_expression" "parenthesized_expression")))
 ("private_property_identifier" (:*unnamed* nil))
 ("program" (:*unnamed* ("statement" "hash_bang_line")))
 ("property_identifier" (:*unnamed* nil))
 ("regex" (:*unnamed* nil :flags ("regex_flags") :pattern ("regex_pattern")))
 ("regex_flags" (:*unnamed* nil))
 ("regex_pattern" (:*unnamed* nil))
 ("rest_pattern" (:*unnamed* ("identifier" "undefined" "member_expression" "object_pattern" "subscript_expression" "array_pattern")))
 ("return_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("sequence_expression" (:*unnamed* nil :left ("expression") :right ("sequence_expression" "expression")))
 ("shorthand_property_identifier" (:*unnamed* nil))
 ("shorthand_property_identifier_pattern" (:*unnamed* nil))
 ("spread_element" (:*unnamed* ("expression")))
 ("statement" (:*unnamed* ("import_statement" "expression_statement" "return_statement" "labeled_statement" "continue_statement" "throw_statement" "debugger_statement" "break_statement" "if_statement" "try_statement" "do_statement" "empty_statement" "while_statement" "declaration" "for_statement" "statement_block" "with_statement" "for_in_statement" "export_statement" "switch_statement")))
 ("statement_block" (:*unnamed* ("statement")))
 ("statement_identifier" (:*unnamed* nil))
 ("string" (:*unnamed* ("escape_sequence" "string_fragment")))
 ("string_fragment" (:*unnamed* nil))
 ("subscript_expression" (:*unnamed* nil :index ("sequence_expression" "expression") :object ("expression") :optional_chain ("optional_chain")))
 ("super" (:*unnamed* nil))
 ("switch_body" (:*unnamed* ("switch_case" "switch_default")))
 ("switch_case" (:*unnamed* nil :body ("statement") :value ("sequence_expression" "expression")))
 ("switch_default" (:*unnamed* nil :body ("statement")))
 ("switch_statement" (:*unnamed* nil :body ("switch_body") :value ("parenthesized_expression")))
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution")))
 ("template_substitution" (:*unnamed* ("sequence_expression" "expression")))
 ("ternary_expression" (:*unnamed* nil :alternative ("expression") :condition ("expression") :consequence ("expression")))
 ("this" (:*unnamed* nil))
 ("throw_statement" (:*unnamed* ("sequence_expression" "expression")))
 ("true" (:*unnamed* nil))
 ("try_statement" (:*unnamed* nil :body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause")))
 ("unary_expression" (:*unnamed* nil :argument ("expression") :operator nil))
 ("undefined" (:*unnamed* nil))
 ("update_expression" (:*unnamed* nil :argument ("expression") :operator nil))
 ("variable_declaration" (:*unnamed* ("variable_declarator")))
 ("variable_declarator" (:*unnamed* nil :name ("identifier" "object_pattern" "array_pattern") :value ("expression")))
 ("while_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression")))
 ("with_statement" (:*unnamed* nil :body ("statement") :object ("parenthesized_expression")))
 ("yield_expression" (:*unnamed* ("expression")))
))
;; END Production rules for javascript
;; START Inverse production rules for javascript
(defconst combobulate-rules-javascript-inverse
 '(("arguments" ("new_expression" "call_expression"))
   ("array" ("primary_expression"))
   ("array_pattern" ("pattern" "object_assignment_pattern" "assignment_expression" "catch_clause" "rest_pattern" "for_in_statement" "variable_declarator"))
   ("arrow_function" ("primary_expression"))
   ("assignment_expression" ("expression"))
   ("assignment_pattern" ("pair_pattern" "formal_parameters" "array_pattern"))
   ("augmented_assignment_expression" ("expression"))
   ("await_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("break_statement" ("statement"))
   ("call_expression" ("primary_expression" "decorator"))
   ("catch_clause" ("try_statement"))
   ("class" ("primary_expression"))
   ("class_body" ("class" "class_declaration"))
   ("class_declaration" ("declaration"))
   ("class_heritage" ("class" "class_declaration"))
   ("class_static_block" ("class_body"))
   ("computed_property_name" ("pair" "method_definition" "pair_pattern" "field_definition"))
   ("continue_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "export_statement"))
   ("decorator" ("method_definition" "field_definition" "class_declaration" "class" "export_statement"))
   ("do_statement" ("statement"))
   ("else_clause" ("if_statement"))
   ("empty_statement" ("for_statement" "statement"))
   ("escape_sequence" ("string" "template_string"))
   ("export_clause" ("export_statement"))
   ("export_specifier" ("export_clause"))
   ("export_statement" ("statement"))
   ("expression" ("arrow_function" "computed_property_name" "member_expression" "augmented_assignment_expression" "ternary_expression" "template_substitution" "class_heritage" "unary_expression" "throw_statement" "update_expression" "pair" "arguments" "binary_expression" "for_statement" "for_in_statement" "array" "export_statement" "yield_expression" "expression_statement" "subscript_expression" "field_definition" "return_statement" "sequence_expression" "switch_case" "assignment_pattern" "variable_declarator" "await_expression" "object_assignment_pattern" "jsx_expression" "assignment_expression" "spread_element" "call_expression" "parenthesized_expression"))
   ("expression_statement" ("for_statement" "statement"))
   ("false" ("primary_expression"))
   ("field_definition" ("class_body"))
   ("finally_clause" ("try_statement"))
   ("for_in_statement" ("statement"))
   ("for_statement" ("statement"))
   ("formal_parameters" ("arrow_function" "method_definition" "generator_function" "generator_function_declaration" "function" "function_declaration"))
   ("function" ("primary_expression"))
   ("function_declaration" ("declaration"))
   ("generator_function" ("primary_expression"))
   ("generator_function_declaration" ("declaration"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("glimmer_template" ("class_body" "expression"))
   ("hash_bang_line" ("program"))
   ("identifier" ("arrow_function" "jsx_closing_element" "namespace_import" "member_expression" "augmented_assignment_expression" "rest_pattern" "function_declaration" "decorator" "generator_function_declaration" "import_specifier" "for_in_statement" "function" "import_clause" "jsx_self_closing_element" "class" "export_specifier" "variable_declarator" "pattern" "namespace_export" "assignment_expression" "catch_clause" "jsx_namespace_name" "class_declaration" "jsx_opening_element" "primary_expression" "generator_function"))
   ("if_statement" ("statement"))
   ("import" ("primary_expression"))
   ("import_clause" ("import_statement"))
   ("import_specifier" ("named_imports"))
   ("import_statement" ("statement"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_element" ("jsx_element" "jsx_attribute" "expression"))
   ("jsx_expression" ("jsx_self_closing_element" "jsx_element" "jsx_opening_element" "jsx_attribute"))
   ("jsx_namespace_name" ("jsx_closing_element" "jsx_self_closing_element" "jsx_opening_element" "jsx_attribute"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_self_closing_element" ("jsx_element" "jsx_attribute" "expression"))
   ("jsx_text" ("jsx_element"))
   ("labeled_statement" ("statement"))
   ("lexical_declaration" ("for_statement" "declaration"))
   ("member_expression" ("jsx_closing_element" "pattern" "augmented_assignment_expression" "member_expression" "decorator" "rest_pattern" "assignment_expression" "jsx_opening_element" "jsx_self_closing_element" "primary_expression" "for_in_statement"))
   ("meta_property" ("primary_expression"))
   ("method_definition" ("object" "class_body"))
   ("named_imports" ("import_clause"))
   ("namespace_export" ("export_statement"))
   ("namespace_import" ("import_clause"))
   ("new_expression" ("new_expression" "expression"))
   ("null" ("primary_expression"))
   ("number" ("pair" "method_definition" "pair_pattern" "field_definition" "primary_expression"))
   ("object" ("primary_expression"))
   ("object_assignment_pattern" ("object_pattern"))
   ("object_pattern" ("pattern" "object_assignment_pattern" "assignment_expression" "catch_clause" "rest_pattern" "for_in_statement" "variable_declarator"))
   ("optional_chain" ("subscript_expression" "member_expression" "call_expression"))
   ("pair" ("object"))
   ("pair_pattern" ("object_pattern"))
   ("parenthesized_expression" ("if_statement" "augmented_assignment_expression" "assignment_expression" "do_statement" "while_statement" "primary_expression" "with_statement" "for_in_statement" "switch_statement"))
   ("pattern" ("pair_pattern" "assignment_pattern" "formal_parameters" "array_pattern"))
   ("primary_expression" ("new_expression" "expression"))
   ("private_property_identifier" ("pair" "method_definition" "member_expression" "binary_expression" "field_definition" "pair_pattern"))
   ("property_identifier" ("pair" "method_definition" "member_expression" "field_definition" "pair_pattern" "jsx_attribute"))
   ("regex" ("primary_expression"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("rest_pattern" ("object_pattern" "pattern"))
   ("return_statement" ("statement"))
   ("sequence_expression" ("expression_statement" "subscript_expression" "jsx_expression" "return_statement" "sequence_expression" "switch_case" "template_substitution" "for_statement" "throw_statement" "for_in_statement" "parenthesized_expression"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_pattern" "object_assignment_pattern"))
   ("spread_element" ("object" "arguments" "jsx_expression" "array"))
   ("statement" ("if_statement" "else_clause" "do_statement" "program" "switch_case" "statement_block" "switch_default" "for_statement" "while_statement" "with_statement" "for_in_statement" "labeled_statement"))
   ("statement_block" ("arrow_function" "class_static_block" "method_definition" "try_statement" "generator_function" "finally_clause" "generator_function_declaration" "statement" "catch_clause" "function" "function_declaration"))
   ("statement_identifier" ("break_statement" "continue_statement" "labeled_statement"))
   ("string" ("pair" "method_definition" "pair_pattern" "import_statement" "field_definition" "namespace_export" "import_specifier" "primary_expression" "export_specifier" "export_statement" "jsx_attribute"))
   ("string_fragment" ("string"))
   ("subscript_expression" ("pattern" "augmented_assignment_expression" "rest_pattern" "assignment_expression" "primary_expression" "for_in_statement"))
   ("super" ("primary_expression"))
   ("switch_body" ("switch_statement"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_statement" ("statement"))
   ("template_string" ("primary_expression" "call_expression"))
   ("template_substitution" ("template_string"))
   ("ternary_expression" ("expression"))
   ("this" ("primary_expression"))
   ("throw_statement" ("statement"))
   ("true" ("primary_expression"))
   ("try_statement" ("statement"))
   ("unary_expression" ("expression"))
   ("undefined" ("pattern" "rest_pattern" "assignment_expression" "primary_expression" "for_in_statement"))
   ("update_expression" ("expression"))
   ("variable_declaration" ("for_statement" "declaration"))
   ("variable_declarator" ("lexical_declaration" "variable_declaration"))
   ("while_statement" ("statement"))
   ("with_statement" ("statement"))
   ("yield_expression" ("expression"))
  )
)
;; END Inverse production rules for javascript
;; START All node types in javascript
(defconst combobulate-rules-javascript-types
 '("arguments" "array" "array_pattern" "arrow_function" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "continue_statement" "debugger_statement" "declaration" "decorator" "do_statement" "else_clause" "empty_statement" "escape_sequence" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "false" "field_definition" "finally_clause" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "generator_function" "generator_function_declaration" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "import" "import_clause" "import_specifier" "import_statement" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "member_expression" "meta_property" "method_definition" "named_imports" "namespace_export" "namespace_import" "new_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "optional_chain" "pair" "pair_pattern" "parenthesized_expression" "pattern" "primary_expression" "private_property_identifier" "program" "property_identifier" "regex" "regex_flags" "regex_pattern" "rest_pattern" "return_statement" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_string" "template_substitution" "ternary_expression" "this" "throw_statement" "true" "try_statement" "unary_expression" "undefined" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression")
)
;; END All node types in javascript
;; START All supertypes in javascript
(defconst combobulate-rules-javascript-supertypes
 '("declaration" "expression" "pattern" "primary_expression" "statement")
)
;; END All supertypes in javascript

;; START Production rules for go
(defconst combobulate-rules-go
 '(("_expression" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("_simple_statement" (:*unnamed* ("dec_statement" "send_statement" "inc_statement" "expression_statement" "short_var_declaration" "assignment_statement")))
 ("_simple_type" (:*unnamed* ("function_type" "negated_type" "type_identifier" "channel_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("_statement" (:*unnamed* ("expression_statement" "return_statement" "select_statement" "continue_statement" "inc_statement" "fallthrough_statement" "for_statement" "go_statement" "type_switch_statement" "break_statement" "send_statement" "if_statement" "const_declaration" "short_var_declaration" "assignment_statement" "goto_statement" "dec_statement" "expression_switch_statement" "type_declaration" "empty_statement" "block" "defer_statement" "var_declaration" "labeled_statement")))
 ("_type" (:*unnamed* ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("argument_list" (:*unnamed* ("channel_type" "int_literal" "variadic_argument" "type_assertion_expression" "slice_expression" "iota" "unary_expression" "selector_expression" "map_type" "float_literal" "binary_expression" "type_conversion_expression" "identifier" "composite_literal" "index_expression" "func_literal" "function_type" "negated_type" "false" "interpreted_string_literal" "slice_type" "struct_type" "generic_type" "true" "array_type" "imaginary_literal" "qualified_type" "pointer_type" "type_identifier" "raw_string_literal" "nil" "parenthesized_type" "union_type" "rune_literal" "interface_type" "call_expression" "parenthesized_expression")))
 ("array_type" (:*unnamed* nil :element ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type") :length ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("assignment_statement" (:*unnamed* nil :left ("expression_list") :operator nil :right ("expression_list")))
 ("binary_expression" (:*unnamed* nil :left ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :operator nil :right ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("blank_identifier" (:*unnamed* nil))
 ("block" (:*unnamed* ("expression_statement" "return_statement" "select_statement" "continue_statement" "inc_statement" "fallthrough_statement" "for_statement" "go_statement" "type_switch_statement" "break_statement" "send_statement" "if_statement" "const_declaration" "short_var_declaration" "assignment_statement" "goto_statement" "dec_statement" "expression_switch_statement" "type_declaration" "empty_statement" "block" "defer_statement" "var_declaration" "labeled_statement")))
 ("break_statement" (:*unnamed* ("label_name")))
 ("call_expression" (:*unnamed* nil :arguments ("argument_list") :function ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :type_arguments ("type_arguments")))
 ("channel_type" (:*unnamed* nil :value ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("comment" (:*unnamed* nil))
 ("communication_case" (:*unnamed* ("expression_statement" "return_statement" "select_statement" "continue_statement" "inc_statement" "fallthrough_statement" "for_statement" "go_statement" "type_switch_statement" "break_statement" "send_statement" "if_statement" "const_declaration" "short_var_declaration" "assignment_statement" "goto_statement" "dec_statement" "expression_switch_statement" "type_declaration" "empty_statement" "block" "defer_statement" "var_declaration" "labeled_statement") :communication ("send_statement" "receive_statement")))
 ("composite_literal" (:*unnamed* nil :body ("literal_value") :type ("type_identifier" "slice_type" "struct_type" "generic_type" "implicit_length_array_type" "array_type" "qualified_type" "map_type")))
 ("const_declaration" (:*unnamed* ("const_spec")))
 ("const_spec" (:*unnamed* nil :name ("identifier") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type") :value ("expression_list")))
 ("continue_statement" (:*unnamed* ("label_name")))
 ("dec_statement" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("default_case" (:*unnamed* ("expression_statement" "return_statement" "select_statement" "continue_statement" "inc_statement" "fallthrough_statement" "for_statement" "go_statement" "type_switch_statement" "break_statement" "send_statement" "if_statement" "const_declaration" "short_var_declaration" "assignment_statement" "goto_statement" "dec_statement" "expression_switch_statement" "type_declaration" "empty_statement" "block" "defer_statement" "var_declaration" "labeled_statement")))
 ("defer_statement" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("dot" (:*unnamed* nil))
 ("empty_statement" (:*unnamed* nil))
 ("escape_sequence" (:*unnamed* nil))
 ("expression_case" (:*unnamed* ("expression_statement" "return_statement" "select_statement" "continue_statement" "inc_statement" "fallthrough_statement" "for_statement" "go_statement" "type_switch_statement" "break_statement" "send_statement" "if_statement" "const_declaration" "short_var_declaration" "assignment_statement" "goto_statement" "dec_statement" "expression_switch_statement" "type_declaration" "empty_statement" "block" "defer_statement" "var_declaration" "labeled_statement") :value ("expression_list")))
 ("expression_list" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("expression_statement" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("expression_switch_statement" (:*unnamed* ("expression_case" "default_case") :initializer ("dec_statement" "send_statement" "inc_statement" "expression_statement" "short_var_declaration" "assignment_statement") :value ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("fallthrough_statement" (:*unnamed* nil))
 ("false" (:*unnamed* nil))
 ("field_declaration" (:*unnamed* nil :name ("field_identifier") :tag ("raw_string_literal" "interpreted_string_literal") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("field_declaration_list" (:*unnamed* ("field_declaration")))
 ("field_identifier" (:*unnamed* nil))
 ("float_literal" (:*unnamed* nil))
 ("for_clause" (:*unnamed* nil :condition ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :initializer ("dec_statement" "send_statement" "inc_statement" "expression_statement" "short_var_declaration" "assignment_statement") :update ("dec_statement" "send_statement" "inc_statement" "expression_statement" "short_var_declaration" "assignment_statement")))
 ("for_statement" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "for_clause" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "range_clause" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :body ("block")))
 ("func_literal" (:*unnamed* nil :body ("block") :parameters ("parameter_list") :result ("function_type" "negated_type" "type_identifier" "channel_type" "slice_type" "struct_type" "union_type" "generic_type" "parameter_list" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("function_declaration" (:*unnamed* nil :body ("block") :name ("identifier") :parameters ("parameter_list") :result ("function_type" "negated_type" "type_identifier" "channel_type" "slice_type" "struct_type" "union_type" "generic_type" "parameter_list" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type") :type_parameters ("type_parameter_list")))
 ("function_type" (:*unnamed* nil :parameters ("parameter_list") :result ("function_type" "negated_type" "type_identifier" "channel_type" "slice_type" "struct_type" "union_type" "generic_type" "parameter_list" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("generic_type" (:*unnamed* nil :type ("negated_type" "type_identifier" "union_type" "qualified_type") :type_arguments ("type_arguments")))
 ("go_statement" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("goto_statement" (:*unnamed* ("label_name")))
 ("identifier" (:*unnamed* nil))
 ("if_statement" (:*unnamed* nil :alternative ("if_statement" "block") :condition ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :consequence ("block") :initializer ("dec_statement" "send_statement" "inc_statement" "expression_statement" "short_var_declaration" "assignment_statement")))
 ("imaginary_literal" (:*unnamed* nil))
 ("implicit_length_array_type" (:*unnamed* nil :element ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("import_declaration" (:*unnamed* ("import_spec_list" "import_spec")))
 ("import_spec" (:*unnamed* nil :name ("blank_identifier" "package_identifier" "dot") :path ("raw_string_literal" "interpreted_string_literal")))
 ("import_spec_list" (:*unnamed* ("import_spec")))
 ("inc_statement" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("index_expression" (:*unnamed* nil :index ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :operand ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("int_literal" (:*unnamed* nil))
 ("interface_type" (:*unnamed* ("method_spec" "constraint_elem" "struct_elem")))
 ("interpreted_string_literal" (:*unnamed* ("escape_sequence")))
 ("iota" (:*unnamed* nil))
 ("keyed_element" (:*unnamed* ("literal_element")))
 ("label_name" (:*unnamed* nil))
 ("labeled_statement" (:*unnamed* ("expression_statement" "return_statement" "select_statement" "continue_statement" "inc_statement" "fallthrough_statement" "for_statement" "go_statement" "type_switch_statement" "break_statement" "send_statement" "if_statement" "const_declaration" "short_var_declaration" "assignment_statement" "goto_statement" "dec_statement" "expression_switch_statement" "type_declaration" "empty_statement" "block" "defer_statement" "var_declaration" "labeled_statement") :label ("label_name")))
 ("literal_element" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "literal_value" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("literal_value" (:*unnamed* ("keyed_element" "literal_element")))
 ("map_type" (:*unnamed* nil :key ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type") :value ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("method_declaration" (:*unnamed* nil :body ("block") :name ("field_identifier") :parameters ("parameter_list") :receiver ("parameter_list") :result ("function_type" "negated_type" "type_identifier" "channel_type" "slice_type" "struct_type" "union_type" "generic_type" "parameter_list" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("method_spec" (:*unnamed* nil :name ("field_identifier") :parameters ("parameter_list") :result ("function_type" "negated_type" "type_identifier" "channel_type" "slice_type" "struct_type" "union_type" "generic_type" "parameter_list" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("negated_type" (:*unnamed* ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("nil" (:*unnamed* nil))
 ("package_clause" (:*unnamed* ("package_identifier")))
 ("package_identifier" (:*unnamed* nil))
 ("parameter_declaration" (:*unnamed* nil :name ("identifier") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("parameter_list" (:*unnamed* ("variadic_parameter_declaration" "parameter_declaration")))
 ("parenthesized_expression" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("parenthesized_type" (:*unnamed* ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("pointer_type" (:*unnamed* ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("qualified_type" (:*unnamed* nil :name ("type_identifier") :package ("package_identifier")))
 ("range_clause" (:*unnamed* nil :left ("expression_list") :right ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("raw_string_literal" (:*unnamed* nil))
 ("receive_statement" (:*unnamed* nil :left ("expression_list") :right ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("return_statement" (:*unnamed* ("expression_list")))
 ("rune_literal" (:*unnamed* nil))
 ("select_statement" (:*unnamed* ("default_case" "communication_case")))
 ("selector_expression" (:*unnamed* nil :field ("field_identifier") :operand ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("send_statement" (:*unnamed* nil :channel ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :value ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("short_var_declaration" (:*unnamed* nil :left ("expression_list") :right ("expression_list")))
 ("slice_expression" (:*unnamed* nil :capacity ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :end ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :operand ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :start ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("slice_type" (:*unnamed* nil :element ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("source_file" (:*unnamed* ("import_declaration" "expression_statement" "method_declaration" "return_statement" "select_statement" "continue_statement" "inc_statement" "fallthrough_statement" "for_statement" "go_statement" "function_declaration" "type_switch_statement" "break_statement" "send_statement" "if_statement" "package_clause" "const_declaration" "short_var_declaration" "assignment_statement" "goto_statement" "dec_statement" "expression_switch_statement" "type_declaration" "empty_statement" "block" "defer_statement" "var_declaration" "labeled_statement")))
 ("struct_elem" (:*unnamed* ("struct_term")))
 ("struct_term" (:*unnamed* ("struct_type")))
 ("struct_type" (:*unnamed* ("field_declaration_list")))
 ("true" (:*unnamed* nil))
 ("type_alias" (:*unnamed* nil :name ("type_identifier") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("type_arguments" (:*unnamed* ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("type_assertion_expression" (:*unnamed* nil :operand ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("type_case" (:*unnamed* ("expression_statement" "return_statement" "select_statement" "continue_statement" "inc_statement" "fallthrough_statement" "for_statement" "go_statement" "type_switch_statement" "break_statement" "send_statement" "if_statement" "const_declaration" "short_var_declaration" "assignment_statement" "goto_statement" "dec_statement" "expression_switch_statement" "type_declaration" "empty_statement" "block" "defer_statement" "var_declaration" "labeled_statement") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("type_conversion_expression" (:*unnamed* nil :operand ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("type_declaration" (:*unnamed* ("type_alias" "type_spec")))
 ("type_identifier" (:*unnamed* nil))
 ("type_parameter_list" (:*unnamed* ("parameter_declaration")))
 ("type_spec" (:*unnamed* nil :name ("type_identifier") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type") :type_parameters ("type_parameter_list")))
 ("type_switch_statement" (:*unnamed* ("type_case" "default_case") :alias ("expression_list") :initializer ("dec_statement" "send_statement" "inc_statement" "expression_statement" "short_var_declaration" "assignment_statement") :value ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("unary_expression" (:*unnamed* nil :operand ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal") :operator nil))
 ("union_type" (:*unnamed* ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
 ("var_declaration" (:*unnamed* ("var_spec")))
 ("var_spec" (:*unnamed* nil :name ("identifier") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type") :value ("expression_list")))
 ("variadic_argument" (:*unnamed* ("int_literal" "false" "interpreted_string_literal" "slice_expression" "true" "iota" "unary_expression" "imaginary_literal" "selector_expression" "raw_string_literal" "nil" "float_literal" "binary_expression" "rune_literal" "type_conversion_expression" "identifier" "call_expression" "composite_literal" "index_expression" "type_assertion_expression" "parenthesized_expression" "func_literal")))
 ("variadic_parameter_declaration" (:*unnamed* nil :name ("identifier") :type ("function_type" "negated_type" "type_identifier" "channel_type" "parenthesized_type" "slice_type" "struct_type" "union_type" "generic_type" "array_type" "interface_type" "qualified_type" "pointer_type" "map_type")))
))
;; END Production rules for go
;; START Inverse production rules for go
(defconst combobulate-rules-go-inverse
 '(("argument_list" ("call_expression"))
   ("array_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "composite_literal" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("assignment_statement" ("expression_case" "type_switch_statement" "if_statement" "type_case" "for_clause" "_statement" "expression_switch_statement" "labeled_statement" "source_file" "block" "communication_case" "default_case" "_simple_statement"))
   ("binary_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("blank_identifier" ("import_spec"))
   ("block" ("expression_case" "if_statement" "method_declaration" "type_case" "_statement" "source_file" "block" "communication_case" "for_statement" "function_declaration" "default_case" "func_literal" "labeled_statement"))
   ("break_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("call_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("channel_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("communication_case" ("select_statement"))
   ("composite_literal" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("const_declaration" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("const_spec" ("const_declaration"))
   ("constraint_elem" ("interface_type"))
   ("continue_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("dec_statement" ("expression_case" "type_switch_statement" "if_statement" "type_case" "for_clause" "_statement" "expression_switch_statement" "labeled_statement" "source_file" "block" "communication_case" "default_case" "_simple_statement"))
   ("default_case" ("expression_switch_statement" "type_switch_statement" "select_statement"))
   ("defer_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("dot" ("import_spec"))
   ("empty_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("escape_sequence" ("interpreted_string_literal"))
   ("expression_case" ("expression_switch_statement"))
   ("expression_list" ("expression_case" "range_clause" "type_switch_statement" "var_spec" "const_spec" "return_statement" "receive_statement" "assignment_statement" "short_var_declaration"))
   ("expression_statement" ("expression_case" "type_switch_statement" "if_statement" "type_case" "for_clause" "_statement" "expression_switch_statement" "labeled_statement" "source_file" "block" "communication_case" "default_case" "_simple_statement"))
   ("expression_switch_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("fallthrough_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("false" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("field_declaration" ("field_declaration_list"))
   ("field_declaration_list" ("struct_type"))
   ("field_identifier" ("field_declaration" "method_spec" "selector_expression" "method_declaration"))
   ("float_literal" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("for_clause" ("for_statement"))
   ("for_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("func_literal" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("function_declaration" ("source_file"))
   ("function_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("generic_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "composite_literal" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("go_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("goto_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("identifier" ("literal_element" "variadic_argument" "const_spec" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "function_declaration" "variadic_parameter_declaration" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "parameter_declaration" "var_spec" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("if_statement" ("expression_case" "if_statement" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("imaginary_literal" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("implicit_length_array_type" ("composite_literal"))
   ("import_declaration" ("source_file"))
   ("import_spec" ("import_spec_list" "import_declaration"))
   ("import_spec_list" ("import_declaration"))
   ("inc_statement" ("expression_case" "type_switch_statement" "if_statement" "type_case" "for_clause" "_statement" "expression_switch_statement" "labeled_statement" "source_file" "block" "communication_case" "default_case" "_simple_statement"))
   ("index_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("int_literal" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("interface_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("interpreted_string_literal" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "field_declaration" "import_spec" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("iota" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("keyed_element" ("literal_value"))
   ("label_name" ("labeled_statement" "break_statement" "continue_statement" "goto_statement"))
   ("labeled_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("literal_element" ("literal_value" "keyed_element"))
   ("literal_value" ("composite_literal" "literal_element"))
   ("map_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "composite_literal" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("method_declaration" ("source_file"))
   ("method_spec" ("interface_type"))
   ("negated_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "generic_type" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("nil" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("package_clause" ("source_file"))
   ("package_identifier" ("import_spec" "package_clause" "qualified_type"))
   ("parameter_declaration" ("type_parameter_list" "parameter_list"))
   ("parameter_list" ("function_type" "method_declaration" "method_spec" "function_declaration" "func_literal"))
   ("parenthesized_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("parenthesized_type" ("channel_type" "const_spec" "argument_list" "variadic_parameter_declaration" "type_spec" "map_type" "type_case" "type_conversion_expression" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("pointer_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("qualified_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "composite_literal" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "generic_type" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("range_clause" ("for_statement"))
   ("raw_string_literal" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "field_declaration" "import_spec" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("receive_statement" ("communication_case"))
   ("return_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("rune_literal" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("select_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("selector_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("send_statement" ("expression_case" "type_switch_statement" "if_statement" "type_case" "for_clause" "_statement" "expression_switch_statement" "labeled_statement" "source_file" "block" "communication_case" "default_case" "_simple_statement"))
   ("short_var_declaration" ("expression_case" "type_switch_statement" "if_statement" "type_case" "for_clause" "_statement" "expression_switch_statement" "labeled_statement" "source_file" "block" "communication_case" "default_case" "_simple_statement"))
   ("slice_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("slice_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "composite_literal" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("struct_elem" ("interface_type"))
   ("struct_term" ("struct_elem"))
   ("struct_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "composite_literal" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "struct_term" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("true" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("type_alias" ("type_declaration"))
   ("type_arguments" ("call_expression" "generic_type"))
   ("type_assertion_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("type_case" ("type_switch_statement"))
   ("type_conversion_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("type_declaration" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("type_identifier" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "composite_literal" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "generic_type" "_type" "array_type" "qualified_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("type_parameter_list" ("function_declaration" "type_spec"))
   ("type_spec" ("type_declaration"))
   ("type_switch_statement" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("unary_expression" ("literal_element" "variadic_argument" "type_assertion_expression" "slice_expression" "_expression" "unary_expression" "argument_list" "selector_expression" "range_clause" "if_statement" "send_statement" "binary_expression" "type_conversion_expression" "receive_statement" "dec_statement" "for_statement" "index_expression" "expression_statement" "for_clause" "array_type" "inc_statement" "go_statement" "type_switch_statement" "expression_switch_statement" "defer_statement" "expression_list" "call_expression" "parenthesized_expression"))
   ("union_type" ("channel_type" "method_declaration" "const_spec" "argument_list" "function_declaration" "variadic_parameter_declaration" "map_type" "type_spec" "type_case" "type_conversion_expression" "method_spec" "_simple_type" "func_literal" "function_type" "negated_type" "slice_type" "var_spec" "generic_type" "_type" "array_type" "type_arguments" "pointer_type" "parenthesized_type" "union_type" "implicit_length_array_type" "field_declaration" "type_alias" "parameter_declaration" "type_assertion_expression"))
   ("var_declaration" ("expression_case" "type_case" "_statement" "source_file" "block" "communication_case" "default_case" "labeled_statement"))
   ("var_spec" ("var_declaration"))
   ("variadic_argument" ("argument_list"))
   ("variadic_parameter_declaration" ("parameter_list"))
  )
)
;; END Inverse production rules for go
;; START All node types in go
(defconst combobulate-rules-go-types
 '("_expression" "_simple_statement" "_simple_type" "_statement" "_type" "argument_list" "array_type" "assignment_statement" "binary_expression" "blank_identifier" "block" "break_statement" "call_expression" "channel_type" "comment" "communication_case" "composite_literal" "const_declaration" "const_spec" "constraint_elem" "continue_statement" "dec_statement" "default_case" "defer_statement" "dot" "empty_statement" "escape_sequence" "expression_case" "expression_list" "expression_statement" "expression_switch_statement" "fallthrough_statement" "false" "field_declaration" "field_declaration_list" "field_identifier" "float_literal" "for_clause" "for_statement" "func_literal" "function_declaration" "function_type" "generic_type" "go_statement" "goto_statement" "identifier" "if_statement" "imaginary_literal" "implicit_length_array_type" "import_declaration" "import_spec" "import_spec_list" "inc_statement" "index_expression" "int_literal" "interface_type" "interpreted_string_literal" "iota" "keyed_element" "label_name" "labeled_statement" "literal_element" "literal_value" "map_type" "method_declaration" "method_spec" "negated_type" "nil" "package_clause" "package_identifier" "parameter_declaration" "parameter_list" "parenthesized_expression" "parenthesized_type" "pointer_type" "qualified_type" "range_clause" "raw_string_literal" "receive_statement" "return_statement" "rune_literal" "select_statement" "selector_expression" "send_statement" "short_var_declaration" "slice_expression" "slice_type" "source_file" "struct_elem" "struct_term" "struct_type" "true" "type_alias" "type_arguments" "type_assertion_expression" "type_case" "type_conversion_expression" "type_declaration" "type_identifier" "type_parameter_list" "type_spec" "type_switch_statement" "unary_expression" "union_type" "var_declaration" "var_spec" "variadic_argument" "variadic_parameter_declaration")
)
;; END All node types in go
;; START All supertypes in go
(defconst combobulate-rules-go-supertypes
 '("_expression" "_simple_statement" "_simple_type" "_statement" "_type")
)
;; END All supertypes in go

;; START Production rules for python
(defconst combobulate-rules-python
 '(("_compound_statement" (:*unnamed* ("if_statement" "try_statement" "function_definition" "match_statement" "while_statement" "for_statement" "with_statement" "class_definition" "decorated_definition")))
 ("_simple_statement" (:*unnamed* ("import_statement" "expression_statement" "return_statement" "assert_statement" "exec_statement" "continue_statement" "delete_statement" "raise_statement" "break_statement" "global_statement" "import_from_statement" "pass_statement" "type_alias_statement" "future_import_statement" "nonlocal_statement" "print_statement")))
 ("aliased_import" (:*unnamed* nil :alias ("identifier") :name ("dotted_name")))
 ("argument_list" (:*unnamed* ("dictionary_splat" "parenthesized_expression" "expression" "list_splat" "keyword_argument")))
 ("as_pattern" (:*unnamed* ("identifier" "case_pattern" "expression") :alias ("as_pattern_target")))
 ("assert_statement" (:*unnamed* ("expression")))
 ("assignment" (:*unnamed* nil :left ("pattern" "pattern_list") :right ("yield" "expression" "pattern_list" "assignment" "expression_list" "augmented_assignment") :type ("type")))
 ("attribute" (:*unnamed* nil :attribute ("identifier") :object ("primary_expression")))
 ("augmented_assignment" (:*unnamed* nil :left ("pattern" "pattern_list") :operator nil :right ("yield" "expression" "pattern_list" "assignment" "expression_list" "augmented_assignment")))
 ("await" (:*unnamed* ("primary_expression")))
 ("binary_operator" (:*unnamed* nil :left ("primary_expression") :operator nil :right ("primary_expression")))
 ("block" (:*unnamed* ("import_statement" "expression_statement" "return_statement" "nonlocal_statement" "assert_statement" "exec_statement" "continue_statement" "delete_statement" "decorated_definition" "raise_statement" "break_statement" "if_statement" "try_statement" "global_statement" "print_statement" "function_definition" "import_from_statement" "match_statement" "type_alias_statement" "future_import_statement" "while_statement" "for_statement" "with_statement" "pass_statement" "class_definition") :alternative ("case_clause")))
 ("boolean_operator" (:*unnamed* nil :left ("expression") :operator nil :right ("expression")))
 ("break_statement" (:*unnamed* nil))
 ("call" (:*unnamed* nil :arguments ("argument_list" "generator_expression") :function ("primary_expression")))
 ("case_clause" (:*unnamed* ("case_pattern") :consequence ("block") :guard ("if_clause")))
 ("case_pattern" (:*unnamed* ("tuple_pattern" "class_pattern" "false" "as_pattern" "string" "none" "true" "dict_pattern" "complex_pattern" "float" "list_pattern" "concatenated_string" "union_pattern" "dotted_name" "integer" "keyword_pattern" "splat_pattern")))
 ("chevron" (:*unnamed* ("expression")))
 ("class_definition" (:*unnamed* nil :body ("block") :name ("identifier") :superclasses ("argument_list") :type_parameters ("type_parameter")))
 ("class_pattern" (:*unnamed* ("case_pattern" "dotted_name")))
 ("comment" (:*unnamed* nil))
 ("comparison_operator" (:*unnamed* ("primary_expression") :operators nil))
 ("complex_pattern" (:*unnamed* ("float" "integer")))
 ("concatenated_string" (:*unnamed* ("string")))
 ("conditional_expression" (:*unnamed* ("expression")))
 ("constrained_type" (:*unnamed* ("type")))
 ("continue_statement" (:*unnamed* nil))
 ("decorated_definition" (:*unnamed* ("decorator") :definition ("class_definition" "function_definition")))
 ("decorator" (:*unnamed* ("expression")))
 ("default_parameter" (:*unnamed* nil :name ("identifier" "tuple_pattern") :value ("expression")))
 ("delete_statement" (:*unnamed* ("expression_list" "expression")))
 ("dict_pattern" (:*unnamed* ("splat_pattern") :key ("tuple_pattern" "class_pattern" "union_pattern" "dotted_name" "false" "string" "none" "true" "integer" "dict_pattern" "complex_pattern" "float" "list_pattern" "splat_pattern" "concatenated_string") :value ("case_pattern")))
 ("dictionary" (:*unnamed* ("dictionary_splat" "pair")))
 ("dictionary_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("pair")))
 ("dictionary_splat" (:*unnamed* ("expression")))
 ("dictionary_splat_pattern" (:*unnamed* ("identifier" "attribute" "subscript")))
 ("dotted_name" (:*unnamed* ("identifier")))
 ("elif_clause" (:*unnamed* nil :condition ("expression") :consequence ("block")))
 ("ellipsis" (:*unnamed* nil))
 ("else_clause" (:*unnamed* nil :body ("block")))
 ("escape_interpolation" (:*unnamed* nil))
 ("escape_sequence" (:*unnamed* nil))
 ("except_clause" (:*unnamed* ("block" "expression")))
 ("except_group_clause" (:*unnamed* ("block" "expression")))
 ("exec_statement" (:*unnamed* ("expression") :code ("identifier" "string")))
 ("expression" (:*unnamed* ("lambda" "conditional_expression" "boolean_operator" "as_pattern" "comparison_operator" "not_operator" "primary_expression" "named_expression")))
 ("expression_list" (:*unnamed* ("expression")))
 ("expression_statement" (:*unnamed* ("assignment" "yield" "augmented_assignment" "expression")))
 ("false" (:*unnamed* nil))
 ("finally_clause" (:*unnamed* ("block")))
 ("float" (:*unnamed* nil))
 ("for_in_clause" (:*unnamed* nil :left ("pattern" "pattern_list") :right ("expression")))
 ("for_statement" (:*unnamed* nil :alternative ("else_clause") :body ("block") :left ("pattern" "pattern_list") :right ("expression_list" "expression")))
 ("format_expression" (:*unnamed* nil :expression ("pattern_list" "expression_list" "yield" "expression") :format_specifier ("format_specifier") :type_conversion ("type_conversion")))
 ("format_specifier" (:*unnamed* ("format_expression")))
 ("function_definition" (:*unnamed* nil :body ("block") :name ("identifier") :parameters ("parameters") :return_type ("type") :type_parameters ("type_parameter")))
 ("future_import_statement" (:*unnamed* nil :name ("dotted_name" "aliased_import")))
 ("generator_expression" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression")))
 ("generic_type" (:*unnamed* ("identifier" "type_parameter")))
 ("global_statement" (:*unnamed* ("identifier")))
 ("identifier" (:*unnamed* nil))
 ("if_clause" (:*unnamed* ("expression")))
 ("if_statement" (:*unnamed* nil :alternative ("else_clause" "elif_clause") :condition ("expression") :consequence ("block")))
 ("import_from_statement" (:*unnamed* ("wildcard_import") :module_name ("dotted_name" "relative_import") :name ("dotted_name" "aliased_import")))
 ("import_prefix" (:*unnamed* nil))
 ("import_statement" (:*unnamed* nil :name ("dotted_name" "aliased_import")))
 ("integer" (:*unnamed* nil))
 ("interpolation" (:*unnamed* nil :expression ("pattern_list" "expression_list" "yield" "expression") :format_specifier ("format_specifier") :type_conversion ("type_conversion")))
 ("keyword_argument" (:*unnamed* nil :name ("identifier") :value ("expression")))
 ("keyword_pattern" (:*unnamed* ("tuple_pattern" "class_pattern" "false" "string" "none" "true" "dict_pattern" "complex_pattern" "float" "list_pattern" "concatenated_string" "union_pattern" "dotted_name" "integer" "identifier" "splat_pattern")))
 ("keyword_separator" (:*unnamed* nil))
 ("lambda" (:*unnamed* nil :body ("expression") :parameters ("lambda_parameters")))
 ("lambda_parameters" (:*unnamed* ("parameter")))
 ("line_continuation" (:*unnamed* nil))
 ("list" (:*unnamed* ("parenthesized_list_splat" "yield" "list_splat" "expression")))
 ("list_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression")))
 ("list_pattern" (:*unnamed* ("case_pattern" "pattern")))
 ("list_splat" (:*unnamed* ("identifier" "attribute" "subscript" "expression")))
 ("list_splat_pattern" (:*unnamed* ("identifier" "attribute" "subscript")))
 ("match_statement" (:*unnamed* nil :body ("block") :subject ("expression")))
 ("member_type" (:*unnamed* ("identifier" "type")))
 ("module" (:*unnamed* ("import_statement" "expression_statement" "return_statement" "nonlocal_statement" "assert_statement" "exec_statement" "continue_statement" "delete_statement" "decorated_definition" "raise_statement" "break_statement" "if_statement" "try_statement" "global_statement" "print_statement" "function_definition" "import_from_statement" "match_statement" "type_alias_statement" "future_import_statement" "while_statement" "for_statement" "with_statement" "pass_statement" "class_definition")))
 ("named_expression" (:*unnamed* nil :name ("identifier") :value ("expression")))
 ("none" (:*unnamed* nil))
 ("nonlocal_statement" (:*unnamed* ("identifier")))
 ("not_operator" (:*unnamed* nil :argument ("expression")))
 ("pair" (:*unnamed* nil :key ("expression") :value ("expression")))
 ("parameter" (:*unnamed* ("tuple_pattern" "dictionary_splat_pattern" "positional_separator" "identifier" "keyword_separator" "list_splat_pattern" "typed_parameter" "default_parameter" "typed_default_parameter")))
 ("parameters" (:*unnamed* ("parameter")))
 ("parenthesized_expression" (:*unnamed* ("parenthesized_expression" "yield" "list_splat" "expression")))
 ("parenthesized_list_splat" (:*unnamed* ("list_splat" "parenthesized_expression")))
 ("pass_statement" (:*unnamed* nil))
 ("pattern" (:*unnamed* ("tuple_pattern" "identifier" "subscript" "list_splat_pattern" "list_pattern" "attribute")))
 ("pattern_list" (:*unnamed* ("pattern")))
 ("positional_separator" (:*unnamed* nil))
 ("primary_expression" (:*unnamed* ("binary_operator" "dictionary_comprehension" "false" "string" "attribute" "ellipsis" "none" "true" "call" "tuple" "subscript" "float" "generator_expression" "concatenated_string" "set_comprehension" "unary_operator" "dictionary" "list_comprehension" "list_splat" "list" "integer" "identifier" "await" "set" "parenthesized_expression")))
 ("print_statement" (:*unnamed* ("chevron") :argument ("expression")))
 ("raise_statement" (:*unnamed* ("expression_list" "expression") :cause ("expression")))
 ("relative_import" (:*unnamed* ("dotted_name" "import_prefix")))
 ("return_statement" (:*unnamed* ("expression_list" "expression")))
 ("set" (:*unnamed* ("parenthesized_list_splat" "yield" "list_splat" "expression")))
 ("set_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression")))
 ("slice" (:*unnamed* ("expression")))
 ("splat_pattern" (:*unnamed* ("identifier")))
 ("splat_type" (:*unnamed* ("identifier")))
 ("string" (:*unnamed* ("string_content" "interpolation" "string_end" "string_start")))
 ("string_content" (:*unnamed* ("escape_sequence" "escape_interpolation")))
 ("string_end" (:*unnamed* nil))
 ("string_start" (:*unnamed* nil))
 ("subscript" (:*unnamed* nil :subscript ("slice" "expression") :value ("primary_expression")))
 ("true" (:*unnamed* nil))
 ("try_statement" (:*unnamed* ("else_clause" "except_clause" "except_group_clause" "finally_clause") :body ("block")))
 ("tuple" (:*unnamed* ("parenthesized_list_splat" "yield" "list_splat" "expression")))
 ("tuple_pattern" (:*unnamed* ("case_pattern" "pattern")))
 ("type" (:*unnamed* ("expression" "splat_type" "union_type" "member_type" "constrained_type" "generic_type")))
 ("type_alias_statement" (:*unnamed* ("type")))
 ("type_conversion" (:*unnamed* nil))
 ("type_parameter" (:*unnamed* ("type")))
 ("typed_default_parameter" (:*unnamed* nil :name ("identifier") :type ("type") :value ("expression")))
 ("typed_parameter" (:*unnamed* ("identifier" "dictionary_splat_pattern" "list_splat_pattern") :type ("type")))
 ("unary_operator" (:*unnamed* nil :argument ("primary_expression") :operator nil))
 ("union_pattern" (:*unnamed* ("tuple_pattern" "class_pattern" "union_pattern" "dotted_name" "false" "string" "none" "true" "integer" "dict_pattern" "complex_pattern" "float" "list_pattern" "splat_pattern" "concatenated_string")))
 ("union_type" (:*unnamed* ("type")))
 ("while_statement" (:*unnamed* nil :alternative ("else_clause") :body ("block") :condition ("expression")))
 ("wildcard_import" (:*unnamed* nil))
 ("with_clause" (:*unnamed* ("with_item")))
 ("with_item" (:*unnamed* nil :value ("expression")))
 ("with_statement" (:*unnamed* ("with_clause") :body ("block")))
 ("yield" (:*unnamed* ("expression_list" "expression")))
))
;; END Production rules for python
;; START Inverse production rules for python
(defconst combobulate-rules-python-inverse
 '(("aliased_import" ("future_import_statement" "import_statement" "import_from_statement"))
   ("argument_list" ("class_definition" "call"))
   ("as_pattern" ("case_pattern" "expression"))
   ("as_pattern_target" ("as_pattern"))
   ("assert_statement" ("module" "block" "_simple_statement"))
   ("assignment" ("assignment" "expression_statement" "augmented_assignment"))
   ("attribute" ("dictionary_splat_pattern" "pattern" "list_splat" "list_splat_pattern" "primary_expression"))
   ("augmented_assignment" ("assignment" "expression_statement" "augmented_assignment"))
   ("await" ("primary_expression"))
   ("binary_operator" ("primary_expression"))
   ("block" ("except_clause" "if_statement" "try_statement" "case_clause" "function_definition" "else_clause" "finally_clause" "except_group_clause" "match_statement" "while_statement" "elif_clause" "for_statement" "with_statement" "class_definition"))
   ("boolean_operator" ("expression"))
   ("break_statement" ("module" "block" "_simple_statement"))
   ("call" ("primary_expression"))
   ("case_clause" ("block"))
   ("case_pattern" ("tuple_pattern" "class_pattern" "case_clause" "as_pattern" "dict_pattern" "list_pattern"))
   ("chevron" ("print_statement"))
   ("class_definition" ("module" "_compound_statement" "block" "decorated_definition"))
   ("class_pattern" ("dict_pattern" "case_pattern" "union_pattern" "keyword_pattern"))
   ("comparison_operator" ("expression"))
   ("complex_pattern" ("dict_pattern" "case_pattern" "union_pattern" "keyword_pattern"))
   ("concatenated_string" ("union_pattern" "keyword_pattern" "dict_pattern" "primary_expression" "case_pattern"))
   ("conditional_expression" ("expression"))
   ("constrained_type" ("type"))
   ("continue_statement" ("module" "block" "_simple_statement"))
   ("decorated_definition" ("module" "_compound_statement" "block"))
   ("decorator" ("decorated_definition"))
   ("default_parameter" ("parameter"))
   ("delete_statement" ("module" "block" "_simple_statement"))
   ("dict_pattern" ("dict_pattern" "case_pattern" "union_pattern" "keyword_pattern"))
   ("dictionary" ("primary_expression"))
   ("dictionary_comprehension" ("primary_expression"))
   ("dictionary_splat" ("argument_list" "dictionary"))
   ("dictionary_splat_pattern" ("parameter" "typed_parameter"))
   ("dotted_name" ("union_pattern" "class_pattern" "aliased_import" "relative_import" "import_statement" "import_from_statement" "keyword_pattern" "dict_pattern" "future_import_statement" "case_pattern"))
   ("elif_clause" ("if_statement"))
   ("ellipsis" ("primary_expression"))
   ("else_clause" ("for_statement" "if_statement" "try_statement" "while_statement"))
   ("escape_interpolation" ("string_content"))
   ("escape_sequence" ("string_content"))
   ("except_clause" ("try_statement"))
   ("except_group_clause" ("try_statement"))
   ("exec_statement" ("module" "block" "_simple_statement"))
   ("expression" ("except_clause" "as_pattern" "not_operator" "except_group_clause" "assert_statement" "dictionary_splat" "exec_statement" "argument_list" "generator_expression" "delete_statement" "set_comprehension" "pair" "if_statement" "interpolation" "yield" "type" "decorator" "list_comprehension" "match_statement" "list_splat" "chevron" "while_statement" "for_statement" "if_clause" "for_in_clause" "augmented_assignment" "print_statement" "conditional_expression" "boolean_operator" "assignment" "expression_statement" "format_expression" "return_statement" "keyword_argument" "slice" "tuple" "subscript" "default_parameter" "named_expression" "lambda" "raise_statement" "with_item" "list" "typed_default_parameter" "elif_clause" "set" "expression_list" "parenthesized_expression"))
   ("expression_list" ("raise_statement" "interpolation" "yield" "assignment" "format_expression" "return_statement" "for_statement" "delete_statement" "augmented_assignment"))
   ("expression_statement" ("module" "block" "_simple_statement"))
   ("false" ("union_pattern" "keyword_pattern" "dict_pattern" "primary_expression" "case_pattern"))
   ("finally_clause" ("try_statement"))
   ("float" ("union_pattern" "keyword_pattern" "dict_pattern" "complex_pattern" "primary_expression" "case_pattern"))
   ("for_in_clause" ("generator_expression" "list_comprehension" "dictionary_comprehension" "set_comprehension"))
   ("for_statement" ("module" "_compound_statement" "block"))
   ("format_expression" ("format_specifier"))
   ("format_specifier" ("format_expression" "interpolation"))
   ("function_definition" ("module" "_compound_statement" "block" "decorated_definition"))
   ("future_import_statement" ("module" "block" "_simple_statement"))
   ("generator_expression" ("primary_expression" "call"))
   ("generic_type" ("type"))
   ("global_statement" ("module" "block" "_simple_statement"))
   ("identifier" ("as_pattern" "exec_statement" "typed_parameter" "list_splat" "keyword_pattern" "nonlocal_statement" "class_definition" "parameter" "attribute" "splat_type" "generic_type" "keyword_argument" "default_parameter" "dictionary_splat_pattern" "pattern" "aliased_import" "dotted_name" "global_statement" "function_definition" "member_type" "list_splat_pattern" "primary_expression" "splat_pattern" "named_expression" "typed_default_parameter"))
   ("if_clause" ("dictionary_comprehension" "case_clause" "list_comprehension" "generator_expression" "set_comprehension"))
   ("if_statement" ("module" "_compound_statement" "block"))
   ("import_from_statement" ("module" "block" "_simple_statement"))
   ("import_prefix" ("relative_import"))
   ("import_statement" ("module" "block" "_simple_statement"))
   ("integer" ("union_pattern" "keyword_pattern" "dict_pattern" "complex_pattern" "primary_expression" "case_pattern"))
   ("interpolation" ("string"))
   ("keyword_argument" ("argument_list"))
   ("keyword_pattern" ("case_pattern"))
   ("keyword_separator" ("parameter"))
   ("lambda" ("expression"))
   ("lambda_parameters" ("lambda"))
   ("list" ("primary_expression"))
   ("list_comprehension" ("primary_expression"))
   ("list_pattern" ("union_pattern" "pattern" "keyword_pattern" "dict_pattern" "case_pattern"))
   ("list_splat" ("argument_list" "list" "tuple" "primary_expression" "set" "parenthesized_list_splat" "parenthesized_expression"))
   ("list_splat_pattern" ("pattern" "parameter" "typed_parameter"))
   ("match_statement" ("module" "_compound_statement" "block"))
   ("member_type" ("type"))
   ("named_expression" ("expression"))
   ("none" ("union_pattern" "keyword_pattern" "dict_pattern" "primary_expression" "case_pattern"))
   ("nonlocal_statement" ("module" "block" "_simple_statement"))
   ("not_operator" ("expression"))
   ("pair" ("dictionary" "dictionary_comprehension"))
   ("parameter" ("lambda_parameters" "parameters"))
   ("parameters" ("function_definition"))
   ("parenthesized_expression" ("primary_expression" "argument_list" "parenthesized_list_splat" "parenthesized_expression"))
   ("parenthesized_list_splat" ("tuple" "set" "list"))
   ("pass_statement" ("module" "block" "_simple_statement"))
   ("pattern" ("tuple_pattern" "pattern_list" "assignment" "list_pattern" "for_statement" "for_in_clause" "augmented_assignment"))
   ("pattern_list" ("interpolation" "assignment" "format_expression" "for_statement" "for_in_clause" "augmented_assignment"))
   ("positional_separator" ("parameter"))
   ("primary_expression" ("binary_operator" "expression" "comparison_operator" "attribute" "call" "subscript" "await" "unary_operator"))
   ("print_statement" ("module" "block" "_simple_statement"))
   ("raise_statement" ("module" "block" "_simple_statement"))
   ("relative_import" ("import_from_statement"))
   ("return_statement" ("module" "block" "_simple_statement"))
   ("set" ("primary_expression"))
   ("set_comprehension" ("primary_expression"))
   ("slice" ("subscript"))
   ("splat_pattern" ("dict_pattern" "case_pattern" "union_pattern" "keyword_pattern"))
   ("splat_type" ("type"))
   ("string" ("union_pattern" "keyword_pattern" "dict_pattern" "exec_statement" "primary_expression" "case_pattern" "concatenated_string"))
   ("string_content" ("string"))
   ("string_end" ("string"))
   ("string_start" ("string"))
   ("subscript" ("dictionary_splat_pattern" "pattern" "list_splat" "list_splat_pattern" "primary_expression"))
   ("true" ("union_pattern" "keyword_pattern" "dict_pattern" "primary_expression" "case_pattern"))
   ("try_statement" ("module" "_compound_statement" "block"))
   ("tuple" ("primary_expression"))
   ("tuple_pattern" ("union_pattern" "pattern" "keyword_pattern" "dict_pattern" "default_parameter" "case_pattern" "parameter"))
   ("type" ("function_definition" "assignment" "union_type" "member_type" "constrained_type" "type_alias_statement" "type_parameter" "typed_parameter" "typed_default_parameter"))
   ("type_alias_statement" ("module" "block" "_simple_statement"))
   ("type_conversion" ("format_expression" "interpolation"))
   ("type_parameter" ("generic_type" "class_definition" "function_definition"))
   ("typed_default_parameter" ("parameter"))
   ("typed_parameter" ("parameter"))
   ("unary_operator" ("primary_expression"))
   ("union_pattern" ("dict_pattern" "case_pattern" "union_pattern" "keyword_pattern"))
   ("union_type" ("type"))
   ("while_statement" ("module" "_compound_statement" "block"))
   ("wildcard_import" ("import_from_statement"))
   ("with_clause" ("with_statement"))
   ("with_item" ("with_clause"))
   ("with_statement" ("module" "_compound_statement" "block"))
   ("yield" ("interpolation" "parenthesized_expression" "assignment" "expression_statement" "format_expression" "list" "tuple" "set" "augmented_assignment"))
  )
)
;; END Inverse production rules for python
;; START All node types in python
(defconst combobulate-rules-python-types
 '("_compound_statement" "_simple_statement" "aliased_import" "argument_list" "as_pattern" "as_pattern_target" "assert_statement" "assignment" "attribute" "augmented_assignment" "await" "binary_operator" "block" "boolean_operator" "break_statement" "call" "case_clause" "case_pattern" "chevron" "class_definition" "class_pattern" "comment" "comparison_operator" "complex_pattern" "concatenated_string" "conditional_expression" "constrained_type" "continue_statement" "decorated_definition" "decorator" "default_parameter" "delete_statement" "dict_pattern" "dictionary" "dictionary_comprehension" "dictionary_splat" "dictionary_splat_pattern" "dotted_name" "elif_clause" "ellipsis" "else_clause" "escape_interpolation" "escape_sequence" "except_clause" "except_group_clause" "exec_statement" "expression" "expression_list" "expression_statement" "false" "finally_clause" "float" "for_in_clause" "for_statement" "format_expression" "format_specifier" "function_definition" "future_import_statement" "generator_expression" "generic_type" "global_statement" "identifier" "if_clause" "if_statement" "import_from_statement" "import_prefix" "import_statement" "integer" "interpolation" "keyword_argument" "keyword_pattern" "keyword_separator" "lambda" "lambda_parameters" "line_continuation" "list" "list_comprehension" "list_pattern" "list_splat" "list_splat_pattern" "match_statement" "member_type" "module" "named_expression" "none" "nonlocal_statement" "not_operator" "pair" "parameter" "parameters" "parenthesized_expression" "parenthesized_list_splat" "pass_statement" "pattern" "pattern_list" "positional_separator" "primary_expression" "print_statement" "raise_statement" "relative_import" "return_statement" "set" "set_comprehension" "slice" "splat_pattern" "splat_type" "string" "string_content" "string_end" "string_start" "subscript" "true" "try_statement" "tuple" "tuple_pattern" "type" "type_alias_statement" "type_conversion" "type_parameter" "typed_default_parameter" "typed_parameter" "unary_operator" "union_pattern" "union_type" "while_statement" "wildcard_import" "with_clause" "with_item" "with_statement" "yield")
)
;; END All node types in python
;; START All supertypes in python
(defconst combobulate-rules-python-supertypes
 '("_compound_statement" "_simple_statement" "expression" "parameter" "pattern" "primary_expression")
)
;; END All supertypes in python

;; START Production rules for html
(defconst combobulate-rules-html
 '(("attribute" (:*unnamed* ("attribute_value" "quoted_attribute_value" "attribute_name")))
 ("attribute_name" (:*unnamed* nil))
 ("attribute_value" (:*unnamed* nil))
 ("comment" (:*unnamed* nil))
 ("doctype" (:*unnamed* nil))
 ("document" (:*unnamed* ("element" "entity" "text" "script_element" "style_element" "erroneous_end_tag" "doctype")))
 ("element" (:*unnamed* ("element" "start_tag" "entity" "style_element" "doctype" "text" "script_element" "erroneous_end_tag" "end_tag" "self_closing_tag")))
 ("end_tag" (:*unnamed* ("tag_name")))
 ("entity" (:*unnamed* nil))
 ("erroneous_end_tag" (:*unnamed* ("erroneous_end_tag_name")))
 ("erroneous_end_tag_name" (:*unnamed* nil))
 ("quoted_attribute_value" (:*unnamed* ("attribute_value")))
 ("raw_text" (:*unnamed* nil))
 ("script_element" (:*unnamed* ("raw_text" "end_tag" "start_tag")))
 ("self_closing_tag" (:*unnamed* ("attribute" "tag_name")))
 ("start_tag" (:*unnamed* ("attribute" "tag_name")))
 ("style_element" (:*unnamed* ("raw_text" "end_tag" "start_tag")))
 ("tag_name" (:*unnamed* nil))
 ("text" (:*unnamed* nil))
))
;; END Production rules for html
;; START Inverse production rules for html
(defconst combobulate-rules-html-inverse
 '(("attribute" ("start_tag" "self_closing_tag"))
   ("attribute_name" ("attribute"))
   ("attribute_value" ("attribute" "quoted_attribute_value"))
   ("doctype" ("element" "document"))
   ("element" ("element" "document"))
   ("end_tag" ("element" "style_element" "script_element"))
   ("entity" ("element" "document"))
   ("erroneous_end_tag" ("element" "document"))
   ("erroneous_end_tag_name" ("erroneous_end_tag"))
   ("quoted_attribute_value" ("attribute"))
   ("raw_text" ("script_element" "style_element"))
   ("script_element" ("element" "document"))
   ("self_closing_tag" ("element"))
   ("start_tag" ("element" "style_element" "script_element"))
   ("style_element" ("element" "document"))
   ("tag_name" ("end_tag" "self_closing_tag" "start_tag"))
   ("text" ("element" "document"))
  )
)
;; END Inverse production rules for html
;; START All node types in html
(defconst combobulate-rules-html-types
 '("attribute" "attribute_name" "attribute_value" "comment" "doctype" "document" "element" "end_tag" "entity" "erroneous_end_tag" "erroneous_end_tag_name" "quoted_attribute_value" "raw_text" "script_element" "self_closing_tag" "start_tag" "style_element" "tag_name" "text")
)
;; END All node types in html
;; START All supertypes in html
(defconst combobulate-rules-html-supertypes
 nil
)
;; END All supertypes in html

;; START Production rules for toml
(defconst combobulate-rules-toml
 '(("array" (:*unnamed* ("local_time" "string" "local_date_time" "inline_table" "integer" "float" "offset_date_time" "boolean" "array" "local_date")))
 ("bare_key" (:*unnamed* nil))
 ("boolean" (:*unnamed* nil))
 ("comment" (:*unnamed* nil))
 ("document" (:*unnamed* ("pair" "table_array_element" "table")))
 ("dotted_key" (:*unnamed* ("bare_key" "quoted_key" "dotted_key")))
 ("escape_sequence" (:*unnamed* nil))
 ("float" (:*unnamed* nil))
 ("inline_table" (:*unnamed* ("pair")))
 ("integer" (:*unnamed* nil))
 ("local_date" (:*unnamed* nil))
 ("local_date_time" (:*unnamed* nil))
 ("local_time" (:*unnamed* nil))
 ("offset_date_time" (:*unnamed* nil))
 ("pair" (:*unnamed* ("local_time" "string" "local_date_time" "quoted_key" "inline_table" "integer" "bare_key" "float" "offset_date_time" "boolean" "array" "dotted_key" "local_date")))
 ("quoted_key" (:*unnamed* ("escape_sequence")))
 ("string" (:*unnamed* ("escape_sequence")))
 ("table" (:*unnamed* ("pair" "bare_key" "quoted_key" "dotted_key")))
 ("table_array_element" (:*unnamed* ("pair" "bare_key" "quoted_key" "dotted_key")))
))
;; END Production rules for toml
;; START Inverse production rules for toml
(defconst combobulate-rules-toml-inverse
 '(("array" ("pair" "array"))
   ("bare_key" ("pair" "dotted_key" "table_array_element" "table"))
   ("boolean" ("pair" "array"))
   ("dotted_key" ("pair" "dotted_key" "table_array_element" "table"))
   ("escape_sequence" ("string" "quoted_key"))
   ("float" ("pair" "array"))
   ("inline_table" ("pair" "array"))
   ("integer" ("pair" "array"))
   ("local_date" ("pair" "array"))
   ("local_date_time" ("pair" "array"))
   ("local_time" ("pair" "array"))
   ("offset_date_time" ("pair" "array"))
   ("pair" ("table" "inline_table" "table_array_element" "document"))
   ("quoted_key" ("pair" "dotted_key" "table_array_element" "table"))
   ("string" ("pair" "array"))
   ("table" ("document"))
   ("table_array_element" ("document"))
  )
)
;; END Inverse production rules for toml
;; START All node types in toml
(defconst combobulate-rules-toml-types
 '("array" "bare_key" "boolean" "comment" "document" "dotted_key" "escape_sequence" "float" "inline_table" "integer" "local_date" "local_date_time" "local_time" "offset_date_time" "pair" "quoted_key" "string" "table" "table_array_element")
)
;; END All node types in toml
;; START All supertypes in toml
(defconst combobulate-rules-toml-supertypes
 nil
)
;; END All supertypes in toml

;; START Production rules for json
(defconst combobulate-rules-json
 '(("_value" (:*unnamed* ("null" "false" "string" "object" "number" "array" "true")))
 ("array" (:*unnamed* ("null" "false" "string" "object" "number" "array" "true")))
 ("comment" (:*unnamed* nil))
 ("document" (:*unnamed* ("null" "false" "string" "object" "number" "array" "true")))
 ("escape_sequence" (:*unnamed* nil))
 ("false" (:*unnamed* nil))
 ("null" (:*unnamed* nil))
 ("number" (:*unnamed* nil))
 ("object" (:*unnamed* ("pair")))
 ("pair" (:*unnamed* nil :key ("string") :value ("null" "false" "string" "object" "number" "array" "true")))
 ("string" (:*unnamed* ("string_content")))
 ("string_content" (:*unnamed* ("escape_sequence")))
 ("true" (:*unnamed* nil))
))
;; END Production rules for json
;; START Inverse production rules for json
(defconst combobulate-rules-json-inverse
 '(("array" ("pair" "_value" "array" "document"))
   ("escape_sequence" ("string_content"))
   ("false" ("pair" "_value" "array" "document"))
   ("null" ("pair" "_value" "array" "document"))
   ("number" ("pair" "_value" "array" "document"))
   ("object" ("pair" "_value" "array" "document"))
   ("pair" ("object"))
   ("string" ("pair" "_value" "array" "document"))
   ("string_content" ("string"))
   ("true" ("pair" "_value" "array" "document"))
  )
)
;; END Inverse production rules for json
;; START All node types in json
(defconst combobulate-rules-json-types
 '("_value" "array" "comment" "document" "escape_sequence" "false" "null" "number" "object" "pair" "string" "string_content" "true")
)
;; END All node types in json
;; START All supertypes in json
(defconst combobulate-rules-json-supertypes
 '("_value")
)
;; END All supertypes in json

;; START Production rules for ocaml
(defconst combobulate-rules-ocaml
 '(("_binding_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("_class_expression" (:*unnamed* ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("_class_field" (:*unnamed* ("method_definition" "inheritance_definition" "quoted_item_extension" "class_initializer" "item_extension" "type_parameter_constraint" "instance_variable_definition")))
 ("_class_field_specification" (:*unnamed* ("quoted_item_extension" "inheritance_specification" "method_specification" "instance_variable_specification" "item_extension" "type_parameter_constraint")))
 ("_class_type" (:*unnamed* ("class_function_type")))
 ("_constant" (:*unnamed* ("character" "unit" "boolean" "string" "number" "quoted_string")))
 ("_effect_pattern" (:*unnamed* ("tag_pattern" "lazy_pattern" "constructor_pattern")))
 ("_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("_infix_operator" (:*unnamed* ("and_operator" "concat_operator" "assign_operator" "add_operator" "or_operator" "rel_operator" "pow_operator" "mult_operator")))
 ("_module_expression" (:*unnamed* ("functor" "module_path" "module_application" "structure")))
 ("_module_type" (:*unnamed* ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("_parameter" (:*unnamed* ("abstract_type" "parameter")))
 ("_pattern" (:*unnamed* ("tuple_pattern" "effect_pattern" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern")))
 ("_polymorphic_type" (:*unnamed* ("polymorphic_type")))
 ("_sequence_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("_signature_item" (:*unnamed* ("floating_attribute" "external" "type_definition" "value_specification" "include_module_type" "open_module" "quoted_item_extension" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("_signed_constant" (:*unnamed* ("character" "unit" "boolean" "signed_number" "string" "number" "quoted_string")))
 ("_simple_class_expression" (:*unnamed* ("extension" "object_expression" "typed_class_expression" "instantiated_class" "quoted_extension" "parenthesized_class_expression" "class_path")))
 ("_simple_class_type" (:*unnamed* ("extension" "class_type_path" "class_body_type" "quoted_extension" "instantiated_class_type" "let_open_class_type")))
 ("_simple_expression" (:*unnamed* ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("_simple_module_expression" (:*unnamed* ("typed_module_expression" "extension" "quoted_extension" "packed_module" "parenthesized_module_expression")))
 ("_simple_pattern" (:*unnamed* ("record_pattern" "signed_number" "string" "tag" "package_pattern" "character" "list_pattern" "polymorphic_variant_pattern" "parenthesized_operator" "boolean" "local_open_pattern" "quoted_extension" "typed_pattern" "unit" "number" "quoted_string" "array_pattern" "parenthesized_pattern" "extension" "constructor_path" "value_pattern")))
 ("_simple_type" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "constructed_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("_structure_item" (:*unnamed* ("floating_attribute" "external" "type_definition" "include_module" "open_module" "quoted_item_extension" "value_definition" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("_tuple_type" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("abstract_type" (:*unnamed* ("type_constructor")))
 ("add_operator" (:*unnamed* nil))
 ("alias_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "value_pattern" "constructor_pattern" "cons_pattern")))
 ("aliased_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("and_operator" (:*unnamed* nil))
 ("application_expression" (:*unnamed* nil :argument ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "labeled_argument" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression") :function ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("array_binding_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("array_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("array_get_expression" (:*unnamed* ("method_invocation" "value_path" "string" "while_expression" "coercion_expression" "tag" "sign_expression" "character" "local_open_expression" "package_expression" "prefix_expression" "lazy_expression" "indexing_operator_path" "object_expression" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "unit" "if_expression" "new_expression" "assert_expression" "let_module_expression" "match_expression" "let_exception_expression" "function_expression" "product_expression" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "typed_expression" "sequence_expression" "string_get_expression" "boolean" "try_expression" "bigarray_get_expression" "array_expression" "cons_expression" "ocamlyacc_value" "number" "for_expression" "let_expression" "quoted_string" "application_expression" "array_get_expression" "extension" "constructor_path" "list_expression" "set_expression" "parenthesized_expression")))
 ("array_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("assert_expression" (:*unnamed* ("attribute_id" "value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("assign_operator" (:*unnamed* nil))
 ("attribute" (:*unnamed* ("attribute_id" "attribute_payload")))
 ("attribute_id" (:*unnamed* nil))
 ("attribute_payload" (:*unnamed* ("tuple_pattern" "lazy_pattern" "alias_pattern" "tuple_type" "or_pattern" "local_open_type" "quoted_item_extension" "value_definition" "range_pattern" "hash_type" "value_specification" "polymorphic_variant_type" "quoted_extension" "include_module_type" "toplevel_directive" "constructed_type" "open_module" "class_type_definition" "constructor_pattern" "class_definition" "function_type" "floating_attribute" "external" "type_definition" "type_variable" "aliased_type" "include_module" "guard" "exception_pattern" "module_type_definition" "item_extension" "package_type" "exception_definition" "effect_pattern" "object_type" "parenthesized_type" "tag_pattern" "expression_item" "extension" "type_constructor_path" "module_definition" "cons_pattern")))
 ("bigarray_get_expression" (:*unnamed* ("method_invocation" "value_path" "string" "while_expression" "coercion_expression" "tag" "sign_expression" "character" "local_open_expression" "package_expression" "prefix_expression" "lazy_expression" "indexing_operator_path" "object_expression" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "unit" "if_expression" "new_expression" "assert_expression" "let_module_expression" "match_expression" "let_exception_expression" "function_expression" "product_expression" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "typed_expression" "sequence_expression" "string_get_expression" "boolean" "try_expression" "bigarray_get_expression" "array_expression" "cons_expression" "ocamlyacc_value" "number" "for_expression" "let_expression" "quoted_string" "application_expression" "array_get_expression" "extension" "constructor_path" "list_expression" "set_expression" "parenthesized_expression")))
 ("boolean" (:*unnamed* nil))
 ("character" (:*unnamed* ("character_content")))
 ("character_content" (:*unnamed* ("escape_sequence")))
 ("class_application" (:*unnamed* nil :argument ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "labeled_argument" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression") :class ("extension" "object_expression" "typed_class_expression" "instantiated_class" "quoted_extension" "parenthesized_class_expression" "class_path")))
 ("class_binding" (:*unnamed* ("class_function_type" "abstract_type" "type_variable" "item_attribute" "parameter") :body ("let_open_class_expression" "let_class_expression" "class_function" "class_application") :name ("class_name")))
 ("class_body_type" (:*unnamed* ("function_type" "floating_attribute" "inheritance_specification" "type_variable" "tuple_type" "aliased_type" "local_open_type" "quoted_item_extension" "instance_variable_specification" "item_extension" "package_type" "object_type" "hash_type" "parenthesized_type" "method_specification" "polymorphic_variant_type" "quoted_extension" "constructed_type" "type_parameter_constraint" "extension" "type_constructor_path")))
 ("class_definition" (:*unnamed* ("attribute_id" "class_binding")))
 ("class_function" (:*unnamed* ("abstract_type" "parameter") :body ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("class_function_type" (:*unnamed* ("class_function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "local_open_type" "extension" "type_constructor_path" "label_name" "package_type")))
 ("class_initializer" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "item_attribute" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("class_name" (:*unnamed* nil))
 ("class_path" (:*unnamed* ("module_path" "class_name")))
 ("class_type_binding" (:*unnamed* ("item_attribute" "type_variable") :body ("extension" "class_type_path" "class_body_type" "quoted_extension" "instantiated_class_type" "let_open_class_type") :name ("class_type_name")))
 ("class_type_definition" (:*unnamed* ("attribute_id" "class_type_binding")))
 ("class_type_name" (:*unnamed* nil))
 ("class_type_path" (:*unnamed* ("extended_module_path" "class_type_name")))
 ("coercion_expression" (:*unnamed* ("tuple_type" "while_expression" "local_open_type" "sign_expression" "lazy_expression" "hash_type" "polymorphic_variant_type" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "constructed_type" "if_expression" "assert_expression" "let_module_expression" "match_expression" "function_type" "let_exception_expression" "type_variable" "function_expression" "product_expression" "aliased_type" "sequence_expression" "try_expression" "package_type" "cons_expression" "object_type" "parenthesized_type" "for_expression" "let_expression" "application_expression" "extension" "type_constructor_path" "set_expression")))
 ("comment" (:*unnamed* nil))
 ("compilation_unit" (:*unnamed* ("floating_attribute" "external" "type_definition" "include_module" "shebang" "quoted_item_extension" "value_definition" "module_type_definition" "item_extension" "exception_definition" "expression_item" "toplevel_directive" "open_module" "class_type_definition" "module_definition" "class_definition")))
 ("concat_operator" (:*unnamed* nil))
 ("cons_expression" (:*unnamed* nil :left ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("cons_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("constrain_module" (:*unnamed* ("module_path" "extended_module_path")))
 ("constrain_module_type" (:*unnamed* ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("constrain_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "type_constraint" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("constructed_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "type_variable" "polymorphic_variant_type" "tuple_type" "quoted_extension" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("constructor_declaration" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "record_declaration" "polymorphic_variant_type" "type_variable" "quoted_extension" "constructed_type" "local_open_type" "extension" "type_constructor_path" "constructor_path" "package_type" "constructor_name")))
 ("constructor_name" (:*unnamed* nil))
 ("constructor_path" (:*unnamed* ("module_path" "constructor_name")))
 ("constructor_pattern" (:*unnamed* ("tuple_pattern" "effect_pattern" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "abstract_type" "constructor_path" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("conversion_specification" (:*unnamed* nil))
 ("directive" (:*unnamed* nil))
 ("do_clause" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("effect_pattern" (:*unnamed* nil :continuation ("record_pattern" "signed_number" "string" "tag" "package_pattern" "character" "list_pattern" "polymorphic_variant_pattern" "parenthesized_operator" "boolean" "local_open_pattern" "quoted_extension" "typed_pattern" "unit" "number" "quoted_string" "array_pattern" "parenthesized_pattern" "extension" "constructor_path" "value_pattern") :effect ("tag_pattern" "lazy_pattern" "constructor_pattern")))
 ("else_clause" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("escape_sequence" (:*unnamed* nil))
 ("exception_definition" (:*unnamed* ("attribute_id" "item_attribute" "constructor_declaration")))
 ("exception_pattern" (:*unnamed* ("tuple_pattern" "effect_pattern" "attribute_id" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern")))
 ("expression_item" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "item_attribute" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("extended_module_path" (:*unnamed* ("module_name" "extended_module_path")))
 ("extension" (:*unnamed* ("attribute_id" "attribute_payload")))
 ("external" (:*unnamed* ("attribute_id" "polymorphic_type" "parenthesized_operator" "value_name" "string" "item_attribute")))
 ("field_declaration" (:*unnamed* ("polymorphic_type" "field_name")))
 ("field_expression" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :name ("field_path")))
 ("field_get_expression" (:*unnamed* ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "field_path" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("field_name" (:*unnamed* nil))
 ("field_path" (:*unnamed* ("field_name" "module_path")))
 ("field_pattern" (:*unnamed* ("tuple_pattern" "function_type" "lazy_pattern" "alias_pattern" "type_variable" "or_pattern" "tuple_type" "aliased_type" "local_open_type" "exception_pattern" "field_path" "package_type" "range_pattern" "effect_pattern" "object_type" "hash_type" "tag_pattern" "parenthesized_type" "polymorphic_variant_type" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "constructor_pattern" "cons_pattern") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("floating_attribute" (:*unnamed* ("attribute_id" "attribute_payload")))
 ("for_expression" (:*unnamed* ("attribute_id" "do_clause") :from ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :name ("parenthesized_operator" "value_pattern") :to ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("fun_expression" (:*unnamed* ("attribute_id" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "constructed_type" "local_open_type" "extension" "abstract_type" "type_constructor_path" "package_type" "parameter") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("function_expression" (:*unnamed* ("attribute_id" "match_case")))
 ("function_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type" "typed_label")))
 ("functor" (:*unnamed* ("module_parameter") :body ("functor" "module_path" "module_application" "structure")))
 ("functor_type" (:*unnamed* ("module_parameter" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("guard" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("hash_expression" (:*unnamed* nil :left ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression") :operator ("hash_operator") :right ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("hash_operator" (:*unnamed* nil))
 ("hash_type" (:*unnamed* ("function_type" "object_type" "hash_type" "class_type_path" "parenthesized_type" "type_variable" "polymorphic_variant_type" "tuple_type" "quoted_extension" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("if_expression" (:*unnamed* ("attribute_id" "then_clause" "else_clause") :condition ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("include_module" (:*unnamed* ("attribute_id" "functor" "module_application" "structure" "item_attribute" "module_path")))
 ("include_module_type" (:*unnamed* ("attribute_id" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "item_attribute" "signature" "module_type_of")))
 ("indexing_operator" (:*unnamed* nil))
 ("indexing_operator_path" (:*unnamed* ("indexing_operator" "module_path")))
 ("infix_expression" (:*unnamed* nil :left ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :operator ("and_operator" "concat_operator" "assign_operator" "add_operator" "or_operator" "rel_operator" "pow_operator" "mult_operator") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("inheritance_definition" (:*unnamed* ("class_function" "item_attribute" "class_application" "parenthesized_operator" "let_open_class_expression" "let_class_expression" "value_pattern")))
 ("inheritance_specification" (:*unnamed* ("extension" "class_type_path" "class_body_type" "quoted_extension" "item_attribute" "instantiated_class_type" "let_open_class_type")))
 ("instance_variable_definition" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "item_attribute" "package_type") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :name ("instance_variable_name")))
 ("instance_variable_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "instance_variable_name" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("instance_variable_name" (:*unnamed* nil))
 ("instance_variable_specification" (:*unnamed* ("function_type" "type_variable" "tuple_type" "aliased_type" "local_open_type" "package_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "instance_variable_name" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "item_attribute")))
 ("instantiated_class" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "class_path" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("instantiated_class_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "class_type_path" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("item_attribute" (:*unnamed* ("attribute_id" "attribute_payload")))
 ("item_extension" (:*unnamed* ("attribute_id" "attribute_payload" "item_attribute")))
 ("label_name" (:*unnamed* nil))
 ("labeled_argument" (:*unnamed* ("value_path" "tuple_type" "string" "local_open_type" "coercion_expression" "tag" "character" "local_open_expression" "package_expression" "prefix_expression" "hash_type" "object_expression" "polymorphic_variant_type" "quoted_extension" "unit" "constructed_type" "new_expression" "label_name" "function_type" "type_variable" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "aliased_type" "typed_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_type" "object_type" "parenthesized_type" "number" "quoted_string" "array_get_expression" "extension" "constructor_path" "type_constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("lazy_expression" (:*unnamed* ("attribute_id" "value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("lazy_pattern" (:*unnamed* ("tuple_pattern" "attribute_id" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("let_and_operator" (:*unnamed* nil))
 ("let_binding" (:*unnamed* ("polymorphic_type" "abstract_type" "item_attribute" "parameter") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("let_class_expression" (:*unnamed* ("value_definition") :body ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("let_exception_expression" (:*unnamed* ("exception_definition") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("let_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "value_definition" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("let_module_expression" (:*unnamed* ("module_definition") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("let_open_class_expression" (:*unnamed* ("open_module") :body ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("let_open_class_type" (:*unnamed* ("open_module") :body ("extension" "class_type_path" "class_body_type" "quoted_extension" "instantiated_class_type" "let_open_class_type")))
 ("let_open_expression" (:*unnamed* ("open_module") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("let_operator" (:*unnamed* nil))
 ("line_number_directive" (:*unnamed* nil))
 ("list_binding_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("list_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("list_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("local_open_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "record_expression" "object_copy_expression" "while_expression" "sign_expression" "sequence_expression" "array_expression" "try_expression" "package_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "module_path" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "list_expression" "set_expression" "let_module_expression")))
 ("local_open_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "record_binding_pattern" "range_pattern" "list_binding_pattern" "array_binding_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "module_path" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("local_open_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "extended_module_path" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("match_case" (:*unnamed* ("guard") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression" "refutation_case") :pattern ("tuple_pattern" "effect_pattern" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern")))
 ("match_expression" (:*unnamed* ("match_expression" "attribute_id" "let_exception_expression" "function_expression" "product_expression" "while_expression" "match_case" "sign_expression" "sequence_expression" "match_operator" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("match_operator" (:*unnamed* nil))
 ("method_definition" (:*unnamed* ("polymorphic_type" "abstract_type" "item_attribute" "parameter") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :name ("method_name")))
 ("method_invocation" (:*unnamed* ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "method_name" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("method_name" (:*unnamed* nil))
 ("method_specification" (:*unnamed* ("polymorphic_type" "item_attribute" "method_name")))
 ("method_type" (:*unnamed* ("polymorphic_type" "method_name")))
 ("module_application" (:*unnamed* nil :argument ("typed_module_expression" "extension" "quoted_extension" "packed_module" "parenthesized_module_expression") :functor ("functor" "module_path" "module_application" "structure")))
 ("module_binding" (:*unnamed* ("module_parameter" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "item_attribute" "signature" "module_type_of") :body ("functor" "module_path" "module_application" "structure") :name ("module_name")))
 ("module_definition" (:*unnamed* ("attribute_id" "module_binding")))
 ("module_name" (:*unnamed* nil))
 ("module_parameter" (:*unnamed* ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of") :name ("module_name")))
 ("module_path" (:*unnamed* ("module_path" "module_name")))
 ("module_type_constraint" (:*unnamed* ("parenthesized_module_type" "constrain_module" "quoted_extension" "constrain_type" "functor_type" "module_type_path" "constrain_module_type" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("module_type_definition" (:*unnamed* ("attribute_id" "item_attribute") :body ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of") :name ("module_type_name")))
 ("module_type_name" (:*unnamed* nil))
 ("module_type_of" (:*unnamed* ("functor" "module_path" "module_application" "structure")))
 ("module_type_path" (:*unnamed* ("extended_module_path" "module_type_name")))
 ("mult_operator" (:*unnamed* nil))
 ("new_expression" (:*unnamed* ("attribute_id" "class_path")))
 ("number" (:*unnamed* nil))
 ("object_copy_expression" (:*unnamed* ("instance_variable_expression")))
 ("object_expression" (:*unnamed* ("tuple_pattern" "lazy_pattern" "alias_pattern" "tuple_type" "or_pattern" "local_open_type" "quoted_item_extension" "range_pattern" "hash_type" "polymorphic_variant_type" "quoted_extension" "constructed_type" "constructor_pattern" "class_initializer" "function_type" "method_definition" "attribute_id" "floating_attribute" "type_variable" "aliased_type" "instance_variable_definition" "inheritance_definition" "exception_pattern" "item_extension" "package_type" "effect_pattern" "object_type" "parenthesized_type" "tag_pattern" "type_parameter_constraint" "extension" "type_constructor_path" "cons_pattern")))
 ("object_type" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "constructed_type" "local_open_type" "extension" "type_constructor_path" "package_type" "method_type")))
 ("ocamlyacc_value" (:*unnamed* nil))
 ("open_module" (:*unnamed* ("attribute_id" "functor" "module_application" "structure" "item_attribute" "module_path")))
 ("or_operator" (:*unnamed* nil))
 ("or_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("package_expression" (:*unnamed* ("attribute_id" "parenthesized_module_type" "structure" "quoted_extension" "module_path" "functor_type" "module_type_path" "functor" "extension" "module_application" "module_type_constraint" "signature" "module_type_of")))
 ("package_pattern" (:*unnamed* ("attribute_id" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_name" "module_type_constraint" "signature" "module_type_of")))
 ("package_type" (:*unnamed* ("attribute_id" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("packed_module" (:*unnamed* ("match_expression" "let_exception_expression" "parenthesized_module_type" "function_expression" "product_expression" "signature" "functor_type" "while_expression" "module_type_path" "sign_expression" "module_type_constraint" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "extension" "assert_expression" "set_expression" "let_module_expression" "module_type_of")))
 ("parameter" (:*unnamed* ("tuple_type" "while_expression" "local_open_type" "sign_expression" "lazy_expression" "hash_type" "polymorphic_variant_type" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "constructed_type" "if_expression" "assert_expression" "label_name" "let_module_expression" "match_expression" "function_type" "let_exception_expression" "type_variable" "function_expression" "product_expression" "aliased_type" "sequence_expression" "try_expression" "package_type" "cons_expression" "object_type" "parenthesized_type" "for_expression" "let_expression" "application_expression" "extension" "type_constructor_path" "set_expression") :pattern ("tuple_pattern" "record_pattern" "lazy_pattern" "alias_pattern" "signed_number" "or_pattern" "string" "tag" "package_pattern" "character" "exception_pattern" "list_pattern" "polymorphic_variant_pattern" "parenthesized_operator" "boolean" "range_pattern" "effect_pattern" "tag_pattern" "local_open_pattern" "quoted_extension" "typed_pattern" "unit" "number" "quoted_string" "array_pattern" "parenthesized_pattern" "extension" "constructor_path" "value_pattern" "constructor_pattern" "cons_pattern")))
 ("parenthesized_class_expression" (:*unnamed* ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("parenthesized_expression" (:*unnamed* ("match_expression" "attribute_id" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("parenthesized_module_expression" (:*unnamed* ("functor" "module_path" "module_application" "structure")))
 ("parenthesized_module_type" (:*unnamed* ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("parenthesized_operator" (:*unnamed* ("let_operator" "hash_operator" "and_operator" "concat_operator" "assign_operator" "indexing_operator" "prefix_operator" "add_operator" "or_operator" "rel_operator" "pow_operator" "mult_operator" "match_operator" "let_and_operator")))
 ("parenthesized_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("parenthesized_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("polymorphic_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "abstract_type" "package_type")))
 ("polymorphic_variant_pattern" (:*unnamed* ("type_constructor_path")))
 ("polymorphic_variant_type" (:*unnamed* ("function_type" "type_variable" "tuple_type" "aliased_type" "local_open_type" "tag" "package_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "tag_specification")))
 ("pow_operator" (:*unnamed* nil))
 ("prefix_expression" (:*unnamed* nil :operator ("prefix_operator") :right ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("prefix_operator" (:*unnamed* nil))
 ("pretty_printing_indication" (:*unnamed* nil))
 ("product_expression" (:*unnamed* nil :left ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("quoted_extension" (:*unnamed* ("attribute_id" "quoted_string_content")))
 ("quoted_item_extension" (:*unnamed* ("attribute_id" "item_attribute" "quoted_string_content")))
 ("quoted_string" (:*unnamed* ("quoted_string_content")))
 ("quoted_string_content" (:*unnamed* ("pretty_printing_indication" "conversion_specification")))
 ("range_pattern" (:*unnamed* ("character" "unit" "boolean" "signed_number" "string" "number" "quoted_string")))
 ("record_binding_pattern" (:*unnamed* ("field_pattern")))
 ("record_declaration" (:*unnamed* ("field_declaration")))
 ("record_expression" (:*unnamed* ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "field_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("record_pattern" (:*unnamed* ("field_pattern")))
 ("refutation_case" (:*unnamed* nil))
 ("rel_operator" (:*unnamed* nil))
 ("sequence_expression" (:*unnamed* ("attribute_id") :left ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("set_expression" (:*unnamed* ("bigarray_get_expression" "instance_variable_name" "string_get_expression" "array_get_expression" "field_get_expression") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("shebang" (:*unnamed* nil))
 ("sign_expression" (:*unnamed* nil :operator ("sign_operator") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("sign_operator" (:*unnamed* nil))
 ("signature" (:*unnamed* ("floating_attribute" "external" "type_definition" "value_specification" "include_module_type" "open_module" "quoted_item_extension" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("signed_number" (:*unnamed* nil))
 ("string" (:*unnamed* ("string_content")))
 ("string_content" (:*unnamed* ("escape_sequence" "conversion_specification" "pretty_printing_indication")))
 ("string_get_expression" (:*unnamed* ("method_invocation" "value_path" "string" "while_expression" "coercion_expression" "tag" "sign_expression" "character" "local_open_expression" "package_expression" "prefix_expression" "lazy_expression" "indexing_operator_path" "object_expression" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "unit" "if_expression" "new_expression" "assert_expression" "let_module_expression" "match_expression" "let_exception_expression" "function_expression" "product_expression" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "typed_expression" "sequence_expression" "string_get_expression" "boolean" "try_expression" "bigarray_get_expression" "array_expression" "cons_expression" "ocamlyacc_value" "number" "for_expression" "let_expression" "quoted_string" "application_expression" "array_get_expression" "extension" "constructor_path" "list_expression" "set_expression" "parenthesized_expression")))
 ("structure" (:*unnamed* ("floating_attribute" "external" "type_definition" "expression_item" "toplevel_directive" "include_module" "open_module" "quoted_item_extension" "value_definition" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("tag" (:*unnamed* nil))
 ("tag_pattern" (:*unnamed* ("tuple_pattern" "effect_pattern" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "tag" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("tag_specification" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "tag" "extension" "type_constructor_path" "package_type")))
 ("then_clause" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("toplevel_directive" (:*unnamed* ("value_path" "directive" "string" "unit" "module_path" "number" "quoted_string" "character" "boolean")))
 ("try_expression" (:*unnamed* ("match_expression" "attribute_id" "let_exception_expression" "function_expression" "product_expression" "while_expression" "match_case" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("tuple_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("tuple_type" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("type_binding" (:*unnamed* ("function_type" "type_variable" "tuple_type" "aliased_type" "local_open_type" "package_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_constraint" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "item_attribute") :body ("variant_declaration" "record_declaration") :name ("type_constructor" "type_constructor_path")))
 ("type_constraint" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("type_constructor" (:*unnamed* nil))
 ("type_constructor_path" (:*unnamed* ("type_constructor" "extended_module_path")))
 ("type_definition" (:*unnamed* ("attribute_id" "type_binding")))
 ("type_parameter_constraint" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "item_attribute" "package_type")))
 ("type_variable" (:*unnamed* nil))
 ("typed_class_expression" (:*unnamed* ("class_function_type" "class_function" "class_application" "let_open_class_expression" "let_class_expression")))
 ("typed_expression" (:*unnamed* ("tuple_type" "while_expression" "local_open_type" "sign_expression" "lazy_expression" "hash_type" "polymorphic_variant_type" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "constructed_type" "if_expression" "assert_expression" "let_module_expression" "match_expression" "function_type" "let_exception_expression" "type_variable" "function_expression" "product_expression" "aliased_type" "sequence_expression" "try_expression" "package_type" "cons_expression" "object_type" "parenthesized_type" "for_expression" "let_expression" "application_expression" "extension" "type_constructor_path" "set_expression")))
 ("typed_label" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "label_name" "package_type")))
 ("typed_module_expression" (:*unnamed* ("parenthesized_module_type" "structure" "quoted_extension" "module_path" "functor_type" "module_type_path" "functor" "extension" "module_application" "module_type_constraint" "signature" "module_type_of")))
 ("typed_pattern" (:*unnamed* ("tuple_pattern" "function_type" "lazy_pattern" "alias_pattern" "type_variable" "or_pattern" "tuple_type" "aliased_type" "local_open_type" "exception_pattern" "package_type" "range_pattern" "effect_pattern" "object_type" "hash_type" "tag_pattern" "parenthesized_type" "polymorphic_variant_type" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "constructor_pattern" "cons_pattern") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("unit" (:*unnamed* nil))
 ("value_definition" (:*unnamed* ("attribute_id" "let_operator" "let_and_operator" "let_binding")))
 ("value_name" (:*unnamed* nil))
 ("value_path" (:*unnamed* ("parenthesized_operator" "module_path" "value_name")))
 ("value_pattern" (:*unnamed* nil))
 ("value_specification" (:*unnamed* ("attribute_id" "polymorphic_type" "value_name" "parenthesized_operator" "item_attribute")))
 ("variant_declaration" (:*unnamed* ("constructor_declaration")))
 ("while_expression" (:*unnamed* ("attribute_id" "do_clause") :condition ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
))
;; END Production rules for ocaml
;; START Inverse production rules for ocaml
(defconst combobulate-rules-ocaml-inverse
 '(("abstract_type" ("method_definition" "class_function" "let_binding" "fun_expression" "_parameter" "class_binding" "constructor_pattern" "polymorphic_type"))
   ("add_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("alias_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("aliased_type" ("attribute_payload" "local_open_type" "coercion_expression" "instantiated_class" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("and_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("application_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("array_binding_pattern" ("local_open_pattern"))
   ("array_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("array_get_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "set_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("array_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("assert_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("assign_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("attribute_id" ("lazy_pattern" "while_expression" "quoted_item_extension" "value_definition" "package_expression" "lazy_expression" "object_expression" "value_specification" "quoted_extension" "fun_expression" "include_module_type" "if_expression" "new_expression" "open_module" "assert_expression" "class_type_definition" "item_attribute" "class_definition" "match_expression" "floating_attribute" "external" "type_definition" "function_expression" "attribute" "include_module" "package_pattern" "sequence_expression" "exception_pattern" "module_type_definition" "item_extension" "package_type" "exception_definition" "try_expression" "for_expression" "extension" "module_definition" "parenthesized_expression"))
   ("attribute_payload" ("floating_attribute" "attribute" "extension" "item_attribute" "item_extension"))
   ("bigarray_get_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "set_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("boolean" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("character" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("character_content" ("character"))
   ("class_application" ("class_function" "typed_class_expression" "parenthesized_class_expression" "let_open_class_expression" "let_class_expression" "inheritance_definition" "class_binding" "_class_expression"))
   ("class_binding" ("class_definition"))
   ("class_body_type" ("class_type_binding" "let_open_class_type" "_simple_class_type" "inheritance_specification"))
   ("class_definition" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("class_function" ("class_function" "typed_class_expression" "parenthesized_class_expression" "let_open_class_expression" "let_class_expression" "inheritance_definition" "class_binding" "_class_expression"))
   ("class_function_type" ("_class_type" "class_binding" "typed_class_expression" "class_function_type"))
   ("class_initializer" ("_class_field" "object_expression"))
   ("class_name" ("class_binding" "class_path"))
   ("class_path" ("new_expression" "_simple_class_expression" "instantiated_class" "class_application"))
   ("class_type_binding" ("class_type_definition"))
   ("class_type_definition" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("class_type_name" ("class_type_binding" "class_type_path"))
   ("class_type_path" ("class_type_binding" "hash_type" "inheritance_specification" "_simple_class_type" "instantiated_class_type" "let_open_class_type"))
   ("coercion_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("concat_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("cons_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("cons_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("constrain_module" ("module_type_constraint"))
   ("constrain_module_type" ("module_type_constraint"))
   ("constrain_type" ("module_type_constraint"))
   ("constructed_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("constructor_declaration" ("variant_declaration" "exception_definition"))
   ("constructor_name" ("constructor_path" "constructor_declaration"))
   ("constructor_path" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "_binding_pattern" "let_binding" "prefix_expression" "lazy_expression" "constructor_declaration" "array_binding_pattern" "labeled_argument" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "assert_expression" "constructor_pattern" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "list_pattern" "string_get_expression" "bigarray_get_expression" "list_binding_pattern" "effect_pattern" "tag_pattern" "array_get_expression" "field_pattern" "application_expression" "array_pattern" "_simple_pattern" "method_invocation" "cons_pattern"))
   ("constructor_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "_effect_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("conversion_specification" ("string_content" "quoted_string_content"))
   ("directive" ("toplevel_directive"))
   ("do_clause" ("for_expression" "while_expression"))
   ("effect_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("else_clause" ("if_expression"))
   ("escape_sequence" ("string_content" "character_content"))
   ("exception_definition" ("attribute_payload" "let_exception_expression" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("exception_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("expression_item" ("attribute_payload" "structure" "compilation_unit"))
   ("extended_module_path" ("class_type_path" "extended_module_path" "constrain_module" "local_open_type" "module_type_path" "type_constructor_path"))
   ("extension" ("tuple_type" "functor_type" "let_binding" "prefix_expression" "module_parameter" "constructed_type" "constrain_module_type" "constructor_pattern" "typed_label" "function_type" "hash_expression" "field_get_expression" "_type" "package_type" "type_binding" "application_expression" "_simple_pattern" "package_expression" "lazy_expression" "_simple_module_expression" "hash_type" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "packed_module" "tag_specification" "_module_type" "_simple_expression" "list_pattern" "module_type_definition" "constrain_type" "effect_pattern" "parenthesized_type" "array_get_expression" "_simple_class_type" "method_invocation" "attribute_payload" "parenthesized_module_type" "lazy_pattern" "or_pattern" "local_open_type" "coercion_expression" "_simple_class_expression" "_binding_pattern" "typed_module_expression" "labeled_argument" "include_module_type" "field_expression" "parenthesized_pattern" "assert_expression" "class_body_type" "polymorphic_type" "parameter" "class_type_binding" "inheritance_specification" "instance_variable_definition" "package_pattern" "module_type_constraint" "string_get_expression" "bigarray_get_expression" "instantiated_class_type" "object_type" "field_pattern" "type_parameter_constraint" "array_pattern" "tuple_pattern" "alias_pattern" "instantiated_class" "module_binding" "constructor_declaration" "array_binding_pattern" "_tuple_type" "class_function_type" "local_open_pattern" "typed_pattern" "_simple_type" "class_application" "record_expression" "aliased_type" "typed_expression" "instance_variable_specification" "list_binding_pattern" "tag_pattern" "module_application" "cons_pattern" "let_open_class_type"))
   ("external" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("field_declaration" ("record_declaration"))
   ("field_expression" ("record_expression"))
   ("field_get_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "set_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("field_name" ("field_declaration" "field_path"))
   ("field_path" ("field_pattern" "field_expression" "field_get_expression"))
   ("field_pattern" ("record_binding_pattern" "record_pattern"))
   ("floating_attribute" ("attribute_payload" "object_expression" "structure" "_structure_item" "compilation_unit" "class_body_type" "signature" "_signature_item"))
   ("for_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("fun_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("function_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("function_type" ("attribute_payload" "local_open_type" "coercion_expression" "instantiated_class" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("functor" ("typed_module_expression" "include_module" "parenthesized_module_expression" "functor" "open_module" "module_application" "_module_expression" "package_expression" "module_binding" "module_type_of"))
   ("functor_type" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("guard" ("match_case" "attribute_payload"))
   ("hash_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("hash_operator" ("parenthesized_operator" "hash_expression"))
   ("hash_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("if_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("include_module" ("_structure_item" "attribute_payload" "structure" "compilation_unit"))
   ("include_module_type" ("attribute_payload" "signature" "_signature_item"))
   ("indexing_operator" ("parenthesized_operator" "indexing_operator_path"))
   ("indexing_operator_path" ("bigarray_get_expression" "array_get_expression" "string_get_expression"))
   ("infix_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("inheritance_definition" ("_class_field" "object_expression"))
   ("inheritance_specification" ("_class_field_specification" "class_body_type"))
   ("instance_variable_definition" ("_class_field" "object_expression"))
   ("instance_variable_expression" ("object_copy_expression"))
   ("instance_variable_name" ("set_expression" "instance_variable_expression" "instance_variable_definition" "instance_variable_specification"))
   ("instance_variable_specification" ("_class_field_specification" "class_body_type"))
   ("instantiated_class" ("_simple_class_expression" "class_application"))
   ("instantiated_class_type" ("class_type_binding" "let_open_class_type" "_simple_class_type" "inheritance_specification"))
   ("item_attribute" ("quoted_item_extension" "let_binding" "module_binding" "value_specification" "include_module_type" "open_module" "class_initializer" "class_type_binding" "external" "method_definition" "inheritance_specification" "instance_variable_definition" "include_module" "class_binding" "inheritance_definition" "module_type_definition" "instance_variable_specification" "item_extension" "exception_definition" "method_specification" "expression_item" "type_parameter_constraint" "type_binding"))
   ("item_extension" ("attribute_payload" "object_expression" "structure" "_structure_item" "compilation_unit" "_class_field" "class_body_type" "_class_field_specification" "signature" "_signature_item"))
   ("label_name" ("class_function_type" "labeled_argument" "typed_label" "parameter"))
   ("labeled_argument" ("application_expression" "class_application"))
   ("lazy_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("lazy_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "_effect_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("let_and_operator" ("parenthesized_operator" "value_definition"))
   ("let_binding" ("value_definition"))
   ("let_class_expression" ("class_function" "typed_class_expression" "parenthesized_class_expression" "let_open_class_expression" "let_class_expression" "inheritance_definition" "class_binding" "_class_expression"))
   ("let_exception_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("let_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("let_module_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("let_open_class_expression" ("class_function" "typed_class_expression" "parenthesized_class_expression" "let_open_class_expression" "let_class_expression" "inheritance_definition" "class_binding" "_class_expression"))
   ("let_open_class_type" ("class_type_binding" "let_open_class_type" "_simple_class_type" "inheritance_specification"))
   ("let_open_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("let_operator" ("parenthesized_operator" "value_definition"))
   ("list_binding_pattern" ("local_open_pattern"))
   ("list_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("list_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("local_open_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("local_open_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("local_open_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("match_case" ("match_expression" "try_expression" "function_expression"))
   ("match_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("match_operator" ("match_expression" "parenthesized_operator"))
   ("method_definition" ("_class_field" "object_expression"))
   ("method_invocation" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("method_name" ("method_invocation" "method_definition" "method_specification" "method_type"))
   ("method_specification" ("_class_field_specification" "class_body_type"))
   ("method_type" ("object_type"))
   ("module_application" ("typed_module_expression" "include_module" "parenthesized_module_expression" "functor" "open_module" "module_application" "_module_expression" "package_expression" "module_binding" "module_type_of"))
   ("module_binding" ("module_definition"))
   ("module_definition" ("attribute_payload" "structure" "_structure_item" "signature" "compilation_unit" "let_module_expression" "_signature_item"))
   ("module_name" ("module_parameter" "extended_module_path" "module_path" "package_pattern" "module_binding"))
   ("module_parameter" ("functor" "module_binding" "functor_type"))
   ("module_path" ("value_path" "local_open_expression" "field_path" "package_expression" "module_binding" "indexing_operator_path" "typed_module_expression" "local_open_pattern" "constrain_module" "toplevel_directive" "parenthesized_module_expression" "open_module" "module_type_of" "include_module" "class_path" "module_path" "functor" "constructor_path" "module_application" "_module_expression"))
   ("module_type_constraint" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("module_type_definition" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("module_type_name" ("module_type_path" "module_type_definition"))
   ("module_type_of" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("module_type_path" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("mult_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("new_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("number" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("object_copy_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("object_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "_simple_class_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("object_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("ocamlyacc_value" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("open_module" ("attribute_payload" "structure" "_structure_item" "let_open_class_expression" "let_open_expression" "compilation_unit" "signature" "let_open_class_type" "_signature_item"))
   ("or_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("or_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("package_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("package_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("package_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("packed_module" ("module_application" "_simple_module_expression"))
   ("parameter" ("method_definition" "class_function" "fun_expression" "_parameter" "class_binding" "let_binding"))
   ("parenthesized_class_expression" ("_simple_class_expression" "class_application"))
   ("parenthesized_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("parenthesized_module_expression" ("module_application" "_simple_module_expression"))
   ("parenthesized_module_type" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("parenthesized_operator" ("tuple_pattern" "value_path" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "value_specification" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "external" "inheritance_definition" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "for_expression" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("parenthesized_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("parenthesized_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("polymorphic_type" ("method_definition" "external" "_polymorphic_type" "method_specification" "value_specification" "field_declaration" "let_binding" "method_type"))
   ("polymorphic_variant_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("polymorphic_variant_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("pow_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("prefix_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("prefix_operator" ("parenthesized_operator" "prefix_expression"))
   ("pretty_printing_indication" ("string_content" "quoted_string_content"))
   ("product_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("quoted_extension" ("tuple_type" "functor_type" "let_binding" "prefix_expression" "module_parameter" "constructed_type" "constrain_module_type" "constructor_pattern" "typed_label" "function_type" "hash_expression" "field_get_expression" "_type" "package_type" "type_binding" "application_expression" "_simple_pattern" "package_expression" "lazy_expression" "_simple_module_expression" "hash_type" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "packed_module" "tag_specification" "_module_type" "_simple_expression" "list_pattern" "module_type_definition" "constrain_type" "effect_pattern" "parenthesized_type" "array_get_expression" "_simple_class_type" "method_invocation" "attribute_payload" "parenthesized_module_type" "lazy_pattern" "or_pattern" "local_open_type" "coercion_expression" "_simple_class_expression" "_binding_pattern" "typed_module_expression" "labeled_argument" "include_module_type" "field_expression" "parenthesized_pattern" "assert_expression" "class_body_type" "polymorphic_type" "parameter" "class_type_binding" "inheritance_specification" "instance_variable_definition" "package_pattern" "module_type_constraint" "string_get_expression" "bigarray_get_expression" "instantiated_class_type" "object_type" "field_pattern" "type_parameter_constraint" "array_pattern" "tuple_pattern" "alias_pattern" "instantiated_class" "module_binding" "constructor_declaration" "array_binding_pattern" "_tuple_type" "class_function_type" "local_open_pattern" "typed_pattern" "_simple_type" "class_application" "record_expression" "aliased_type" "typed_expression" "instance_variable_specification" "list_binding_pattern" "tag_pattern" "module_application" "cons_pattern" "let_open_class_type"))
   ("quoted_item_extension" ("attribute_payload" "object_expression" "structure" "_structure_item" "compilation_unit" "_class_field" "class_body_type" "_class_field_specification" "signature" "_signature_item"))
   ("quoted_string" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("quoted_string_content" ("quoted_item_extension" "quoted_string" "quoted_extension"))
   ("range_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("record_binding_pattern" ("local_open_pattern"))
   ("record_declaration" ("type_binding" "constructor_declaration"))
   ("record_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("record_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("refutation_case" ("match_case"))
   ("rel_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("sequence_expression" ("while_expression" "coercion_expression" "local_open_expression" "let_binding" "fun_expression" "let_open_expression" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "parameter" "match_expression" "method_definition" "let_exception_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "bigarray_get_expression" "try_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "parenthesized_expression"))
   ("set_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("shebang" ("compilation_unit"))
   ("sign_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("sign_operator" ("sign_expression"))
   ("signature" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("signed_number" ("effect_pattern" "_simple_pattern" "_signed_constant" "range_pattern" "parameter"))
   ("string" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "external" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("string_content" ("string"))
   ("string_get_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "set_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("structure" ("typed_module_expression" "include_module" "parenthesized_module_expression" "functor" "open_module" "module_application" "_module_expression" "package_expression" "module_binding" "module_type_of"))
   ("tag" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "_binding_pattern" "let_binding" "prefix_expression" "lazy_expression" "array_binding_pattern" "labeled_argument" "local_open_pattern" "polymorphic_variant_type" "typed_pattern" "parenthesized_pattern" "tag_specification" "assert_expression" "constructor_pattern" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "list_pattern" "string_get_expression" "bigarray_get_expression" "list_binding_pattern" "effect_pattern" "tag_pattern" "array_get_expression" "field_pattern" "application_expression" "array_pattern" "_simple_pattern" "method_invocation" "cons_pattern"))
   ("tag_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "_effect_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("tag_specification" ("polymorphic_variant_type"))
   ("then_clause" ("if_expression"))
   ("toplevel_directive" ("attribute_payload" "structure" "compilation_unit"))
   ("try_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("tuple_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("tuple_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("type_binding" ("type_definition"))
   ("type_constraint" ("type_binding" "constrain_type"))
   ("type_constructor" ("type_constructor_path" "abstract_type" "type_binding"))
   ("type_constructor_path" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "polymorphic_variant_pattern" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("type_definition" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("type_parameter_constraint" ("_class_field" "_class_field_specification" "object_expression" "class_body_type"))
   ("type_variable" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "class_type_binding" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "class_binding" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("typed_class_expression" ("_simple_class_expression" "class_application"))
   ("typed_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("typed_label" ("function_type"))
   ("typed_module_expression" ("module_application" "_simple_module_expression"))
   ("typed_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("unit" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("value_definition" ("attribute_payload" "structure" "_structure_item" "let_class_expression" "let_expression" "compilation_unit"))
   ("value_name" ("tuple_pattern" "value_path" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "value_specification" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "external" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("value_path" ("labeled_argument" "class_application" "toplevel_directive" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("value_pattern" ("effect_pattern" "alias_pattern" "for_expression" "inheritance_definition" "_simple_pattern" "parameter"))
   ("value_specification" ("attribute_payload" "signature" "_signature_item"))
   ("variant_declaration" ("type_binding"))
   ("while_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
  )
)
;; END Inverse production rules for ocaml
;; START All node types in ocaml
(defconst combobulate-rules-ocaml-types
 '("_binding_pattern" "_class_expression" "_class_field" "_class_field_specification" "_class_type" "_constant" "_effect_pattern" "_expression" "_infix_operator" "_module_expression" "_module_type" "_parameter" "_pattern" "_polymorphic_type" "_sequence_expression" "_signature_item" "_signed_constant" "_simple_class_expression" "_simple_class_type" "_simple_expression" "_simple_module_expression" "_simple_pattern" "_simple_type" "_structure_item" "_tuple_type" "_type" "abstract_type" "add_operator" "alias_pattern" "aliased_type" "and_operator" "application_expression" "array_binding_pattern" "array_expression" "array_get_expression" "array_pattern" "assert_expression" "assign_operator" "attribute" "attribute_id" "attribute_payload" "bigarray_get_expression" "boolean" "character" "character_content" "class_application" "class_binding" "class_body_type" "class_definition" "class_function" "class_function_type" "class_initializer" "class_name" "class_path" "class_type_binding" "class_type_definition" "class_type_name" "class_type_path" "coercion_expression" "comment" "compilation_unit" "concat_operator" "cons_expression" "cons_pattern" "constrain_module" "constrain_module_type" "constrain_type" "constructed_type" "constructor_declaration" "constructor_name" "constructor_path" "constructor_pattern" "conversion_specification" "directive" "do_clause" "effect_pattern" "else_clause" "escape_sequence" "exception_definition" "exception_pattern" "expression_item" "extended_module_path" "extension" "external" "field_declaration" "field_expression" "field_get_expression" "field_name" "field_path" "field_pattern" "floating_attribute" "for_expression" "fun_expression" "function_expression" "function_type" "functor" "functor_type" "guard" "hash_expression" "hash_operator" "hash_type" "if_expression" "include_module" "include_module_type" "indexing_operator" "indexing_operator_path" "infix_expression" "inheritance_definition" "inheritance_specification" "instance_variable_definition" "instance_variable_expression" "instance_variable_name" "instance_variable_specification" "instantiated_class" "instantiated_class_type" "item_attribute" "item_extension" "label_name" "labeled_argument" "lazy_expression" "lazy_pattern" "let_and_operator" "let_binding" "let_class_expression" "let_exception_expression" "let_expression" "let_module_expression" "let_open_class_expression" "let_open_class_type" "let_open_expression" "let_operator" "line_number_directive" "list_binding_pattern" "list_expression" "list_pattern" "local_open_expression" "local_open_pattern" "local_open_type" "match_case" "match_expression" "match_operator" "method_definition" "method_invocation" "method_name" "method_specification" "method_type" "module_application" "module_binding" "module_definition" "module_name" "module_parameter" "module_path" "module_type_constraint" "module_type_definition" "module_type_name" "module_type_of" "module_type_path" "mult_operator" "new_expression" "number" "object_copy_expression" "object_expression" "object_type" "ocamlyacc_value" "open_module" "or_operator" "or_pattern" "package_expression" "package_pattern" "package_type" "packed_module" "parameter" "parenthesized_class_expression" "parenthesized_expression" "parenthesized_module_expression" "parenthesized_module_type" "parenthesized_operator" "parenthesized_pattern" "parenthesized_type" "polymorphic_type" "polymorphic_variant_pattern" "polymorphic_variant_type" "pow_operator" "prefix_expression" "prefix_operator" "pretty_printing_indication" "product_expression" "quoted_extension" "quoted_item_extension" "quoted_string" "quoted_string_content" "range_pattern" "record_binding_pattern" "record_declaration" "record_expression" "record_pattern" "refutation_case" "rel_operator" "sequence_expression" "set_expression" "shebang" "sign_expression" "sign_operator" "signature" "signed_number" "string" "string_content" "string_get_expression" "structure" "tag" "tag_pattern" "tag_specification" "then_clause" "toplevel_directive" "try_expression" "tuple_pattern" "tuple_type" "type_binding" "type_constraint" "type_constructor" "type_constructor_path" "type_definition" "type_parameter_constraint" "type_variable" "typed_class_expression" "typed_expression" "typed_label" "typed_module_expression" "typed_pattern" "unit" "value_definition" "value_name" "value_path" "value_pattern" "value_specification" "variant_declaration" "while_expression")
)
;; END All node types in ocaml
;; START All supertypes in ocaml
(defconst combobulate-rules-ocaml-supertypes
 '("_binding_pattern" "_class_expression" "_class_field" "_class_field_specification" "_class_type" "_constant" "_effect_pattern" "_expression" "_infix_operator" "_module_expression" "_module_type" "_parameter" "_pattern" "_polymorphic_type" "_sequence_expression" "_signature_item" "_signed_constant" "_simple_class_expression" "_simple_class_type" "_simple_expression" "_simple_module_expression" "_simple_pattern" "_simple_type" "_structure_item" "_tuple_type" "_type")
)
;; END All supertypes in ocaml

;; START Production rules for ocamli
(defconst combobulate-rules-ocaml-interface
 '(("_binding_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("_class_expression" (:*unnamed* ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("_class_field" (:*unnamed* ("method_definition" "inheritance_definition" "quoted_item_extension" "class_initializer" "item_extension" "type_parameter_constraint" "instance_variable_definition")))
 ("_class_field_specification" (:*unnamed* ("quoted_item_extension" "inheritance_specification" "method_specification" "instance_variable_specification" "item_extension" "type_parameter_constraint")))
 ("_class_type" (:*unnamed* ("class_function_type")))
 ("_constant" (:*unnamed* ("character" "unit" "boolean" "string" "number" "quoted_string")))
 ("_effect_pattern" (:*unnamed* ("tag_pattern" "lazy_pattern" "constructor_pattern")))
 ("_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("_infix_operator" (:*unnamed* ("and_operator" "concat_operator" "assign_operator" "add_operator" "or_operator" "rel_operator" "pow_operator" "mult_operator")))
 ("_module_expression" (:*unnamed* ("functor" "module_path" "module_application" "structure")))
 ("_module_type" (:*unnamed* ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("_parameter" (:*unnamed* ("abstract_type" "parameter")))
 ("_pattern" (:*unnamed* ("tuple_pattern" "effect_pattern" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern")))
 ("_polymorphic_type" (:*unnamed* ("polymorphic_type")))
 ("_sequence_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("_signature_item" (:*unnamed* ("floating_attribute" "external" "type_definition" "value_specification" "include_module_type" "open_module" "quoted_item_extension" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("_signed_constant" (:*unnamed* ("character" "unit" "boolean" "signed_number" "string" "number" "quoted_string")))
 ("_simple_class_expression" (:*unnamed* ("extension" "object_expression" "typed_class_expression" "instantiated_class" "quoted_extension" "parenthesized_class_expression" "class_path")))
 ("_simple_class_type" (:*unnamed* ("extension" "class_type_path" "class_body_type" "quoted_extension" "instantiated_class_type" "let_open_class_type")))
 ("_simple_expression" (:*unnamed* ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("_simple_module_expression" (:*unnamed* ("typed_module_expression" "extension" "quoted_extension" "packed_module" "parenthesized_module_expression")))
 ("_simple_pattern" (:*unnamed* ("record_pattern" "signed_number" "string" "tag" "package_pattern" "character" "list_pattern" "polymorphic_variant_pattern" "parenthesized_operator" "boolean" "local_open_pattern" "quoted_extension" "typed_pattern" "unit" "number" "quoted_string" "array_pattern" "parenthesized_pattern" "extension" "constructor_path" "value_pattern")))
 ("_simple_type" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "constructed_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("_structure_item" (:*unnamed* ("floating_attribute" "external" "type_definition" "include_module" "open_module" "quoted_item_extension" "value_definition" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("_tuple_type" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("abstract_type" (:*unnamed* ("type_constructor")))
 ("add_operator" (:*unnamed* nil))
 ("alias_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "value_pattern" "constructor_pattern" "cons_pattern")))
 ("aliased_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("and_operator" (:*unnamed* nil))
 ("application_expression" (:*unnamed* nil :argument ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "labeled_argument" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression") :function ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("array_binding_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("array_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("array_get_expression" (:*unnamed* ("method_invocation" "value_path" "string" "while_expression" "coercion_expression" "tag" "sign_expression" "character" "local_open_expression" "package_expression" "prefix_expression" "lazy_expression" "indexing_operator_path" "object_expression" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "unit" "if_expression" "new_expression" "assert_expression" "let_module_expression" "match_expression" "let_exception_expression" "function_expression" "product_expression" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "typed_expression" "sequence_expression" "string_get_expression" "boolean" "try_expression" "bigarray_get_expression" "array_expression" "cons_expression" "ocamlyacc_value" "number" "for_expression" "let_expression" "quoted_string" "application_expression" "array_get_expression" "extension" "constructor_path" "list_expression" "set_expression" "parenthesized_expression")))
 ("array_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("assert_expression" (:*unnamed* ("attribute_id" "value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("assign_operator" (:*unnamed* nil))
 ("attribute" (:*unnamed* ("attribute_id" "attribute_payload")))
 ("attribute_id" (:*unnamed* nil))
 ("attribute_payload" (:*unnamed* ("tuple_pattern" "lazy_pattern" "alias_pattern" "tuple_type" "or_pattern" "local_open_type" "quoted_item_extension" "value_definition" "range_pattern" "hash_type" "value_specification" "polymorphic_variant_type" "quoted_extension" "include_module_type" "toplevel_directive" "constructed_type" "open_module" "class_type_definition" "constructor_pattern" "class_definition" "function_type" "floating_attribute" "external" "type_definition" "type_variable" "aliased_type" "include_module" "guard" "exception_pattern" "module_type_definition" "item_extension" "package_type" "exception_definition" "effect_pattern" "object_type" "parenthesized_type" "tag_pattern" "expression_item" "extension" "type_constructor_path" "module_definition" "cons_pattern")))
 ("bigarray_get_expression" (:*unnamed* ("method_invocation" "value_path" "string" "while_expression" "coercion_expression" "tag" "sign_expression" "character" "local_open_expression" "package_expression" "prefix_expression" "lazy_expression" "indexing_operator_path" "object_expression" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "unit" "if_expression" "new_expression" "assert_expression" "let_module_expression" "match_expression" "let_exception_expression" "function_expression" "product_expression" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "typed_expression" "sequence_expression" "string_get_expression" "boolean" "try_expression" "bigarray_get_expression" "array_expression" "cons_expression" "ocamlyacc_value" "number" "for_expression" "let_expression" "quoted_string" "application_expression" "array_get_expression" "extension" "constructor_path" "list_expression" "set_expression" "parenthesized_expression")))
 ("boolean" (:*unnamed* nil))
 ("character" (:*unnamed* ("character_content")))
 ("character_content" (:*unnamed* ("escape_sequence")))
 ("class_application" (:*unnamed* nil :argument ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "labeled_argument" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression") :class ("extension" "object_expression" "typed_class_expression" "instantiated_class" "quoted_extension" "parenthesized_class_expression" "class_path")))
 ("class_binding" (:*unnamed* ("class_function_type" "abstract_type" "type_variable" "item_attribute" "parameter") :body ("let_open_class_expression" "let_class_expression" "class_function" "class_application") :name ("class_name")))
 ("class_body_type" (:*unnamed* ("function_type" "floating_attribute" "inheritance_specification" "type_variable" "tuple_type" "aliased_type" "local_open_type" "quoted_item_extension" "instance_variable_specification" "item_extension" "package_type" "object_type" "hash_type" "parenthesized_type" "method_specification" "polymorphic_variant_type" "quoted_extension" "constructed_type" "type_parameter_constraint" "extension" "type_constructor_path")))
 ("class_definition" (:*unnamed* ("attribute_id" "class_binding")))
 ("class_function" (:*unnamed* ("abstract_type" "parameter") :body ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("class_function_type" (:*unnamed* ("class_function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "local_open_type" "extension" "type_constructor_path" "label_name" "package_type")))
 ("class_initializer" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "item_attribute" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("class_name" (:*unnamed* nil))
 ("class_path" (:*unnamed* ("module_path" "class_name")))
 ("class_type_binding" (:*unnamed* ("item_attribute" "type_variable") :body ("extension" "class_type_path" "class_body_type" "quoted_extension" "instantiated_class_type" "let_open_class_type") :name ("class_type_name")))
 ("class_type_definition" (:*unnamed* ("attribute_id" "class_type_binding")))
 ("class_type_name" (:*unnamed* nil))
 ("class_type_path" (:*unnamed* ("extended_module_path" "class_type_name")))
 ("coercion_expression" (:*unnamed* ("tuple_type" "while_expression" "local_open_type" "sign_expression" "lazy_expression" "hash_type" "polymorphic_variant_type" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "constructed_type" "if_expression" "assert_expression" "let_module_expression" "match_expression" "function_type" "let_exception_expression" "type_variable" "function_expression" "product_expression" "aliased_type" "sequence_expression" "try_expression" "package_type" "cons_expression" "object_type" "parenthesized_type" "for_expression" "let_expression" "application_expression" "extension" "type_constructor_path" "set_expression")))
 ("comment" (:*unnamed* nil))
 ("compilation_unit" (:*unnamed* ("floating_attribute" "external" "type_definition" "value_specification" "include_module_type" "open_module" "quoted_item_extension" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("concat_operator" (:*unnamed* nil))
 ("cons_expression" (:*unnamed* nil :left ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("cons_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("constrain_module" (:*unnamed* ("module_path" "extended_module_path")))
 ("constrain_module_type" (:*unnamed* ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("constrain_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "type_constraint" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("constructed_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "type_variable" "polymorphic_variant_type" "tuple_type" "quoted_extension" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("constructor_declaration" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "record_declaration" "polymorphic_variant_type" "type_variable" "quoted_extension" "constructed_type" "local_open_type" "extension" "type_constructor_path" "constructor_path" "package_type" "constructor_name")))
 ("constructor_name" (:*unnamed* nil))
 ("constructor_path" (:*unnamed* ("module_path" "constructor_name")))
 ("constructor_pattern" (:*unnamed* ("tuple_pattern" "effect_pattern" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "abstract_type" "constructor_path" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("conversion_specification" (:*unnamed* nil))
 ("directive" (:*unnamed* nil))
 ("do_clause" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("effect_pattern" (:*unnamed* nil :continuation ("record_pattern" "signed_number" "string" "tag" "package_pattern" "character" "list_pattern" "polymorphic_variant_pattern" "parenthesized_operator" "boolean" "local_open_pattern" "quoted_extension" "typed_pattern" "unit" "number" "quoted_string" "array_pattern" "parenthesized_pattern" "extension" "constructor_path" "value_pattern") :effect ("tag_pattern" "lazy_pattern" "constructor_pattern")))
 ("else_clause" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("escape_sequence" (:*unnamed* nil))
 ("exception_definition" (:*unnamed* ("attribute_id" "item_attribute" "constructor_declaration")))
 ("exception_pattern" (:*unnamed* ("tuple_pattern" "effect_pattern" "attribute_id" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern")))
 ("expression_item" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "item_attribute" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("extended_module_path" (:*unnamed* ("module_name" "extended_module_path")))
 ("extension" (:*unnamed* ("attribute_id" "attribute_payload")))
 ("external" (:*unnamed* ("attribute_id" "polymorphic_type" "parenthesized_operator" "value_name" "string" "item_attribute")))
 ("field_declaration" (:*unnamed* ("polymorphic_type" "field_name")))
 ("field_expression" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :name ("field_path")))
 ("field_get_expression" (:*unnamed* ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "field_path" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("field_name" (:*unnamed* nil))
 ("field_path" (:*unnamed* ("field_name" "module_path")))
 ("field_pattern" (:*unnamed* ("tuple_pattern" "function_type" "lazy_pattern" "alias_pattern" "type_variable" "or_pattern" "tuple_type" "aliased_type" "local_open_type" "exception_pattern" "field_path" "package_type" "range_pattern" "effect_pattern" "object_type" "hash_type" "tag_pattern" "parenthesized_type" "polymorphic_variant_type" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "constructor_pattern" "cons_pattern") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("floating_attribute" (:*unnamed* ("attribute_id" "attribute_payload")))
 ("for_expression" (:*unnamed* ("attribute_id" "do_clause") :from ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :name ("parenthesized_operator" "value_pattern") :to ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("fun_expression" (:*unnamed* ("attribute_id" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "constructed_type" "local_open_type" "extension" "abstract_type" "type_constructor_path" "package_type" "parameter") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("function_expression" (:*unnamed* ("attribute_id" "match_case")))
 ("function_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type" "typed_label")))
 ("functor" (:*unnamed* ("module_parameter") :body ("functor" "module_path" "module_application" "structure")))
 ("functor_type" (:*unnamed* ("module_parameter" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("guard" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("hash_expression" (:*unnamed* nil :left ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression") :operator ("hash_operator") :right ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("hash_operator" (:*unnamed* nil))
 ("hash_type" (:*unnamed* ("function_type" "object_type" "hash_type" "class_type_path" "parenthesized_type" "type_variable" "polymorphic_variant_type" "tuple_type" "quoted_extension" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("if_expression" (:*unnamed* ("attribute_id" "then_clause" "else_clause") :condition ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("include_module" (:*unnamed* ("attribute_id" "functor" "module_application" "structure" "item_attribute" "module_path")))
 ("include_module_type" (:*unnamed* ("attribute_id" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "item_attribute" "signature" "module_type_of")))
 ("indexing_operator" (:*unnamed* nil))
 ("indexing_operator_path" (:*unnamed* ("indexing_operator" "module_path")))
 ("infix_expression" (:*unnamed* nil :left ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :operator ("and_operator" "concat_operator" "assign_operator" "add_operator" "or_operator" "rel_operator" "pow_operator" "mult_operator") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("inheritance_definition" (:*unnamed* ("class_function" "item_attribute" "class_application" "parenthesized_operator" "let_open_class_expression" "let_class_expression" "value_pattern")))
 ("inheritance_specification" (:*unnamed* ("extension" "class_type_path" "class_body_type" "quoted_extension" "item_attribute" "instantiated_class_type" "let_open_class_type")))
 ("instance_variable_definition" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "item_attribute" "package_type") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :name ("instance_variable_name")))
 ("instance_variable_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "instance_variable_name" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("instance_variable_name" (:*unnamed* nil))
 ("instance_variable_specification" (:*unnamed* ("function_type" "type_variable" "tuple_type" "aliased_type" "local_open_type" "package_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "instance_variable_name" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "item_attribute")))
 ("instantiated_class" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "class_path" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("instantiated_class_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "class_type_path" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("item_attribute" (:*unnamed* ("attribute_id" "attribute_payload")))
 ("item_extension" (:*unnamed* ("attribute_id" "attribute_payload" "item_attribute")))
 ("label_name" (:*unnamed* nil))
 ("labeled_argument" (:*unnamed* ("value_path" "tuple_type" "string" "local_open_type" "coercion_expression" "tag" "character" "local_open_expression" "package_expression" "prefix_expression" "hash_type" "object_expression" "polymorphic_variant_type" "quoted_extension" "unit" "constructed_type" "new_expression" "label_name" "function_type" "type_variable" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "aliased_type" "typed_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_type" "object_type" "parenthesized_type" "number" "quoted_string" "array_get_expression" "extension" "constructor_path" "type_constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("lazy_expression" (:*unnamed* ("attribute_id" "value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("lazy_pattern" (:*unnamed* ("tuple_pattern" "attribute_id" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("let_and_operator" (:*unnamed* nil))
 ("let_binding" (:*unnamed* ("polymorphic_type" "abstract_type" "item_attribute" "parameter") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("let_class_expression" (:*unnamed* ("value_definition") :body ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("let_exception_expression" (:*unnamed* ("exception_definition") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("let_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "value_definition" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("let_module_expression" (:*unnamed* ("module_definition") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("let_open_class_expression" (:*unnamed* ("open_module") :body ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("let_open_class_type" (:*unnamed* ("open_module") :body ("extension" "class_type_path" "class_body_type" "quoted_extension" "instantiated_class_type" "let_open_class_type")))
 ("let_open_expression" (:*unnamed* ("open_module") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("let_operator" (:*unnamed* nil))
 ("line_number_directive" (:*unnamed* nil))
 ("list_binding_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("list_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("list_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("local_open_expression" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "record_expression" "object_copy_expression" "while_expression" "sign_expression" "sequence_expression" "array_expression" "try_expression" "package_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "module_path" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "list_expression" "set_expression" "let_module_expression")))
 ("local_open_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "record_binding_pattern" "range_pattern" "list_binding_pattern" "array_binding_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "module_path" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("local_open_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "extended_module_path" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("match_case" (:*unnamed* ("guard") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression" "refutation_case") :pattern ("tuple_pattern" "effect_pattern" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern")))
 ("match_expression" (:*unnamed* ("match_expression" "attribute_id" "let_exception_expression" "function_expression" "product_expression" "while_expression" "match_case" "sign_expression" "sequence_expression" "match_operator" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("match_operator" (:*unnamed* nil))
 ("method_definition" (:*unnamed* ("polymorphic_type" "abstract_type" "item_attribute" "parameter") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :name ("method_name")))
 ("method_invocation" (:*unnamed* ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "method_name" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("method_name" (:*unnamed* nil))
 ("method_specification" (:*unnamed* ("polymorphic_type" "item_attribute" "method_name")))
 ("method_type" (:*unnamed* ("polymorphic_type" "method_name")))
 ("module_application" (:*unnamed* nil :argument ("typed_module_expression" "extension" "quoted_extension" "packed_module" "parenthesized_module_expression") :functor ("functor" "module_path" "module_application" "structure")))
 ("module_binding" (:*unnamed* ("module_parameter" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "item_attribute" "signature" "module_type_of") :body ("functor" "module_path" "module_application" "structure") :name ("module_name")))
 ("module_definition" (:*unnamed* ("attribute_id" "module_binding")))
 ("module_name" (:*unnamed* nil))
 ("module_parameter" (:*unnamed* ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of") :name ("module_name")))
 ("module_path" (:*unnamed* ("module_path" "module_name")))
 ("module_type_constraint" (:*unnamed* ("parenthesized_module_type" "constrain_module" "quoted_extension" "constrain_type" "functor_type" "module_type_path" "constrain_module_type" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("module_type_definition" (:*unnamed* ("attribute_id" "item_attribute") :body ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of") :name ("module_type_name")))
 ("module_type_name" (:*unnamed* nil))
 ("module_type_of" (:*unnamed* ("functor" "module_path" "module_application" "structure")))
 ("module_type_path" (:*unnamed* ("extended_module_path" "module_type_name")))
 ("mult_operator" (:*unnamed* nil))
 ("new_expression" (:*unnamed* ("attribute_id" "class_path")))
 ("number" (:*unnamed* nil))
 ("object_copy_expression" (:*unnamed* ("instance_variable_expression")))
 ("object_expression" (:*unnamed* ("tuple_pattern" "lazy_pattern" "alias_pattern" "tuple_type" "or_pattern" "local_open_type" "quoted_item_extension" "range_pattern" "hash_type" "polymorphic_variant_type" "quoted_extension" "constructed_type" "constructor_pattern" "class_initializer" "function_type" "method_definition" "attribute_id" "floating_attribute" "type_variable" "aliased_type" "instance_variable_definition" "inheritance_definition" "exception_pattern" "item_extension" "package_type" "effect_pattern" "object_type" "parenthesized_type" "tag_pattern" "type_parameter_constraint" "extension" "type_constructor_path" "cons_pattern")))
 ("object_type" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "constructed_type" "local_open_type" "extension" "type_constructor_path" "package_type" "method_type")))
 ("ocamlyacc_value" (:*unnamed* nil))
 ("open_module" (:*unnamed* ("attribute_id" "functor" "module_application" "structure" "item_attribute" "module_path")))
 ("or_operator" (:*unnamed* nil))
 ("or_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("package_expression" (:*unnamed* ("attribute_id" "parenthesized_module_type" "structure" "quoted_extension" "module_path" "functor_type" "module_type_path" "functor" "extension" "module_application" "module_type_constraint" "signature" "module_type_of")))
 ("package_pattern" (:*unnamed* ("attribute_id" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_name" "module_type_constraint" "signature" "module_type_of")))
 ("package_type" (:*unnamed* ("attribute_id" "parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("packed_module" (:*unnamed* ("match_expression" "let_exception_expression" "parenthesized_module_type" "function_expression" "product_expression" "signature" "functor_type" "while_expression" "module_type_path" "sign_expression" "module_type_constraint" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "extension" "assert_expression" "set_expression" "let_module_expression" "module_type_of")))
 ("parameter" (:*unnamed* ("tuple_type" "while_expression" "local_open_type" "sign_expression" "lazy_expression" "hash_type" "polymorphic_variant_type" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "constructed_type" "if_expression" "assert_expression" "label_name" "let_module_expression" "match_expression" "function_type" "let_exception_expression" "type_variable" "function_expression" "product_expression" "aliased_type" "sequence_expression" "try_expression" "package_type" "cons_expression" "object_type" "parenthesized_type" "for_expression" "let_expression" "application_expression" "extension" "type_constructor_path" "set_expression") :pattern ("tuple_pattern" "record_pattern" "lazy_pattern" "alias_pattern" "signed_number" "or_pattern" "string" "tag" "package_pattern" "character" "exception_pattern" "list_pattern" "polymorphic_variant_pattern" "parenthesized_operator" "boolean" "range_pattern" "effect_pattern" "tag_pattern" "local_open_pattern" "quoted_extension" "typed_pattern" "unit" "number" "quoted_string" "array_pattern" "parenthesized_pattern" "extension" "constructor_path" "value_pattern" "constructor_pattern" "cons_pattern")))
 ("parenthesized_class_expression" (:*unnamed* ("let_open_class_expression" "let_class_expression" "class_function" "class_application")))
 ("parenthesized_expression" (:*unnamed* ("match_expression" "attribute_id" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("parenthesized_module_expression" (:*unnamed* ("functor" "module_path" "module_application" "structure")))
 ("parenthesized_module_type" (:*unnamed* ("parenthesized_module_type" "quoted_extension" "functor_type" "module_type_path" "extension" "module_type_constraint" "signature" "module_type_of")))
 ("parenthesized_operator" (:*unnamed* ("let_operator" "hash_operator" "and_operator" "concat_operator" "assign_operator" "indexing_operator" "prefix_operator" "add_operator" "or_operator" "rel_operator" "pow_operator" "mult_operator" "match_operator" "let_and_operator")))
 ("parenthesized_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("parenthesized_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("polymorphic_type" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "abstract_type" "package_type")))
 ("polymorphic_variant_pattern" (:*unnamed* ("type_constructor_path")))
 ("polymorphic_variant_type" (:*unnamed* ("function_type" "type_variable" "tuple_type" "aliased_type" "local_open_type" "tag" "package_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "tag_specification")))
 ("pow_operator" (:*unnamed* nil))
 ("prefix_expression" (:*unnamed* nil :operator ("prefix_operator") :right ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("prefix_operator" (:*unnamed* nil))
 ("pretty_printing_indication" (:*unnamed* nil))
 ("product_expression" (:*unnamed* nil :left ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("quoted_extension" (:*unnamed* ("attribute_id" "quoted_string_content")))
 ("quoted_item_extension" (:*unnamed* ("attribute_id" "item_attribute" "quoted_string_content")))
 ("quoted_string" (:*unnamed* ("quoted_string_content")))
 ("quoted_string_content" (:*unnamed* ("pretty_printing_indication" "conversion_specification")))
 ("range_pattern" (:*unnamed* ("character" "unit" "boolean" "signed_number" "string" "number" "quoted_string")))
 ("record_binding_pattern" (:*unnamed* ("field_pattern")))
 ("record_declaration" (:*unnamed* ("field_declaration")))
 ("record_expression" (:*unnamed* ("value_path" "string" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "coercion_expression" "tag" "typed_expression" "character" "local_open_expression" "string_get_expression" "boolean" "bigarray_get_expression" "array_expression" "ocamlyacc_value" "package_expression" "prefix_expression" "object_expression" "quoted_extension" "unit" "number" "quoted_string" "array_get_expression" "field_expression" "new_expression" "extension" "constructor_path" "list_expression" "method_invocation" "parenthesized_expression")))
 ("record_pattern" (:*unnamed* ("field_pattern")))
 ("refutation_case" (:*unnamed* nil))
 ("rel_operator" (:*unnamed* nil))
 ("sequence_expression" (:*unnamed* ("attribute_id") :left ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("set_expression" (:*unnamed* ("bigarray_get_expression" "instance_variable_name" "string_get_expression" "array_get_expression" "field_get_expression") :body ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("sign_expression" (:*unnamed* nil :operator ("sign_operator") :right ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("sign_operator" (:*unnamed* nil))
 ("signature" (:*unnamed* ("floating_attribute" "external" "type_definition" "value_specification" "include_module_type" "open_module" "quoted_item_extension" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("signed_number" (:*unnamed* nil))
 ("string" (:*unnamed* ("string_content")))
 ("string_content" (:*unnamed* ("escape_sequence" "conversion_specification" "pretty_printing_indication")))
 ("string_get_expression" (:*unnamed* ("method_invocation" "value_path" "string" "while_expression" "coercion_expression" "tag" "sign_expression" "character" "local_open_expression" "package_expression" "prefix_expression" "lazy_expression" "indexing_operator_path" "object_expression" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "unit" "if_expression" "new_expression" "assert_expression" "let_module_expression" "match_expression" "let_exception_expression" "function_expression" "product_expression" "record_expression" "object_copy_expression" "hash_expression" "field_get_expression" "typed_expression" "sequence_expression" "string_get_expression" "boolean" "try_expression" "bigarray_get_expression" "array_expression" "cons_expression" "ocamlyacc_value" "number" "for_expression" "let_expression" "quoted_string" "application_expression" "array_get_expression" "extension" "constructor_path" "list_expression" "set_expression" "parenthesized_expression")))
 ("structure" (:*unnamed* ("floating_attribute" "external" "type_definition" "expression_item" "toplevel_directive" "include_module" "open_module" "quoted_item_extension" "value_definition" "class_type_definition" "module_definition" "module_type_definition" "item_extension" "exception_definition" "class_definition")))
 ("tag" (:*unnamed* nil))
 ("tag_pattern" (:*unnamed* ("tuple_pattern" "effect_pattern" "tag_pattern" "lazy_pattern" "alias_pattern" "or_pattern" "tag" "exception_pattern" "constructor_pattern" "cons_pattern" "range_pattern") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("tag_specification" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "tag" "extension" "type_constructor_path" "package_type")))
 ("then_clause" (:*unnamed* ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("toplevel_directive" (:*unnamed* ("value_path" "directive" "string" "unit" "module_path" "number" "quoted_string" "character" "boolean")))
 ("try_expression" (:*unnamed* ("match_expression" "attribute_id" "let_exception_expression" "function_expression" "product_expression" "while_expression" "match_case" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
 ("tuple_pattern" (:*unnamed* ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "exception_pattern" "range_pattern" "effect_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("tuple_type" (:*unnamed* ("object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("type_binding" (:*unnamed* ("function_type" "type_variable" "tuple_type" "aliased_type" "local_open_type" "package_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_constraint" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "item_attribute") :body ("variant_declaration" "record_declaration") :name ("type_constructor" "type_constructor_path")))
 ("type_constraint" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "package_type")))
 ("type_constructor" (:*unnamed* nil))
 ("type_constructor_path" (:*unnamed* ("type_constructor" "extended_module_path")))
 ("type_definition" (:*unnamed* ("attribute_id" "type_binding")))
 ("type_parameter_constraint" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "item_attribute" "package_type")))
 ("type_variable" (:*unnamed* nil))
 ("typed_class_expression" (:*unnamed* ("class_function_type" "class_function" "class_application" "let_open_class_expression" "let_class_expression")))
 ("typed_expression" (:*unnamed* ("tuple_type" "while_expression" "local_open_type" "sign_expression" "lazy_expression" "hash_type" "polymorphic_variant_type" "infix_expression" "quoted_extension" "fun_expression" "let_open_expression" "constructed_type" "if_expression" "assert_expression" "let_module_expression" "match_expression" "function_type" "let_exception_expression" "type_variable" "function_expression" "product_expression" "aliased_type" "sequence_expression" "try_expression" "package_type" "cons_expression" "object_type" "parenthesized_type" "for_expression" "let_expression" "application_expression" "extension" "type_constructor_path" "set_expression")))
 ("typed_label" (:*unnamed* ("function_type" "object_type" "hash_type" "parenthesized_type" "polymorphic_variant_type" "type_variable" "quoted_extension" "tuple_type" "constructed_type" "aliased_type" "local_open_type" "extension" "type_constructor_path" "label_name" "package_type")))
 ("typed_module_expression" (:*unnamed* ("parenthesized_module_type" "structure" "quoted_extension" "module_path" "functor_type" "module_type_path" "functor" "extension" "module_application" "module_type_constraint" "signature" "module_type_of")))
 ("typed_pattern" (:*unnamed* ("tuple_pattern" "function_type" "lazy_pattern" "alias_pattern" "type_variable" "or_pattern" "tuple_type" "aliased_type" "local_open_type" "exception_pattern" "package_type" "range_pattern" "effect_pattern" "object_type" "hash_type" "tag_pattern" "parenthesized_type" "polymorphic_variant_type" "quoted_extension" "constructed_type" "extension" "type_constructor_path" "constructor_pattern" "cons_pattern") :pattern ("tuple_pattern" "record_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "tag" "package_pattern" "polymorphic_variant_pattern" "list_pattern" "value_name" "parenthesized_operator" "range_pattern" "local_open_pattern" "tag_pattern" "quoted_extension" "typed_pattern" "parenthesized_pattern" "array_pattern" "extension" "constructor_path" "constructor_pattern" "cons_pattern")))
 ("unit" (:*unnamed* nil))
 ("value_definition" (:*unnamed* ("attribute_id" "let_operator" "let_and_operator" "let_binding")))
 ("value_name" (:*unnamed* nil))
 ("value_path" (:*unnamed* ("parenthesized_operator" "module_path" "value_name")))
 ("value_pattern" (:*unnamed* nil))
 ("value_specification" (:*unnamed* ("attribute_id" "polymorphic_type" "value_name" "parenthesized_operator" "item_attribute")))
 ("variant_declaration" (:*unnamed* ("constructor_declaration")))
 ("while_expression" (:*unnamed* ("attribute_id" "do_clause") :condition ("match_expression" "let_exception_expression" "function_expression" "product_expression" "while_expression" "sign_expression" "sequence_expression" "try_expression" "lazy_expression" "cons_expression" "infix_expression" "fun_expression" "let_open_expression" "for_expression" "let_expression" "application_expression" "if_expression" "assert_expression" "set_expression" "let_module_expression")))
))
;; END Production rules for ocamli
;; START Inverse production rules for ocamli
(defconst combobulate-rules-ocaml-interface-inverse
 '(("abstract_type" ("method_definition" "class_function" "let_binding" "fun_expression" "_parameter" "class_binding" "constructor_pattern" "polymorphic_type"))
   ("add_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("alias_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("aliased_type" ("attribute_payload" "local_open_type" "coercion_expression" "instantiated_class" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("and_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("application_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("array_binding_pattern" ("local_open_pattern"))
   ("array_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("array_get_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "set_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("array_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("assert_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("assign_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("attribute_id" ("lazy_pattern" "while_expression" "quoted_item_extension" "value_definition" "package_expression" "lazy_expression" "object_expression" "value_specification" "quoted_extension" "fun_expression" "include_module_type" "if_expression" "new_expression" "open_module" "assert_expression" "class_type_definition" "item_attribute" "class_definition" "match_expression" "floating_attribute" "external" "type_definition" "function_expression" "attribute" "include_module" "package_pattern" "sequence_expression" "exception_pattern" "module_type_definition" "item_extension" "package_type" "exception_definition" "try_expression" "for_expression" "extension" "module_definition" "parenthesized_expression"))
   ("attribute_payload" ("floating_attribute" "attribute" "extension" "item_attribute" "item_extension"))
   ("bigarray_get_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "set_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("boolean" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("character" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("character_content" ("character"))
   ("class_application" ("class_function" "typed_class_expression" "parenthesized_class_expression" "let_open_class_expression" "let_class_expression" "inheritance_definition" "class_binding" "_class_expression"))
   ("class_binding" ("class_definition"))
   ("class_body_type" ("class_type_binding" "let_open_class_type" "_simple_class_type" "inheritance_specification"))
   ("class_definition" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("class_function" ("class_function" "typed_class_expression" "parenthesized_class_expression" "let_open_class_expression" "let_class_expression" "inheritance_definition" "class_binding" "_class_expression"))
   ("class_function_type" ("_class_type" "class_binding" "typed_class_expression" "class_function_type"))
   ("class_initializer" ("_class_field" "object_expression"))
   ("class_name" ("class_binding" "class_path"))
   ("class_path" ("new_expression" "_simple_class_expression" "instantiated_class" "class_application"))
   ("class_type_binding" ("class_type_definition"))
   ("class_type_definition" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("class_type_name" ("class_type_binding" "class_type_path"))
   ("class_type_path" ("class_type_binding" "hash_type" "inheritance_specification" "_simple_class_type" "instantiated_class_type" "let_open_class_type"))
   ("coercion_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("concat_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("cons_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("cons_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("constrain_module" ("module_type_constraint"))
   ("constrain_module_type" ("module_type_constraint"))
   ("constrain_type" ("module_type_constraint"))
   ("constructed_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("constructor_declaration" ("variant_declaration" "exception_definition"))
   ("constructor_name" ("constructor_path" "constructor_declaration"))
   ("constructor_path" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "_binding_pattern" "let_binding" "prefix_expression" "lazy_expression" "constructor_declaration" "array_binding_pattern" "labeled_argument" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "assert_expression" "constructor_pattern" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "list_pattern" "string_get_expression" "bigarray_get_expression" "list_binding_pattern" "effect_pattern" "tag_pattern" "array_get_expression" "field_pattern" "application_expression" "array_pattern" "_simple_pattern" "method_invocation" "cons_pattern"))
   ("constructor_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "_effect_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("conversion_specification" ("string_content" "quoted_string_content"))
   ("directive" ("toplevel_directive"))
   ("do_clause" ("for_expression" "while_expression"))
   ("effect_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("else_clause" ("if_expression"))
   ("escape_sequence" ("string_content" "character_content"))
   ("exception_definition" ("attribute_payload" "let_exception_expression" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("exception_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("expression_item" ("attribute_payload" "structure"))
   ("extended_module_path" ("class_type_path" "extended_module_path" "constrain_module" "local_open_type" "module_type_path" "type_constructor_path"))
   ("extension" ("tuple_type" "functor_type" "let_binding" "prefix_expression" "module_parameter" "constructed_type" "constrain_module_type" "constructor_pattern" "typed_label" "function_type" "hash_expression" "field_get_expression" "_type" "package_type" "type_binding" "application_expression" "_simple_pattern" "package_expression" "lazy_expression" "_simple_module_expression" "hash_type" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "packed_module" "tag_specification" "_module_type" "_simple_expression" "list_pattern" "module_type_definition" "constrain_type" "effect_pattern" "parenthesized_type" "array_get_expression" "_simple_class_type" "method_invocation" "attribute_payload" "parenthesized_module_type" "lazy_pattern" "or_pattern" "local_open_type" "coercion_expression" "_simple_class_expression" "_binding_pattern" "typed_module_expression" "labeled_argument" "include_module_type" "field_expression" "parenthesized_pattern" "assert_expression" "class_body_type" "polymorphic_type" "parameter" "class_type_binding" "inheritance_specification" "instance_variable_definition" "package_pattern" "module_type_constraint" "string_get_expression" "bigarray_get_expression" "instantiated_class_type" "object_type" "field_pattern" "type_parameter_constraint" "array_pattern" "tuple_pattern" "alias_pattern" "instantiated_class" "module_binding" "constructor_declaration" "array_binding_pattern" "_tuple_type" "class_function_type" "local_open_pattern" "typed_pattern" "_simple_type" "class_application" "record_expression" "aliased_type" "typed_expression" "instance_variable_specification" "list_binding_pattern" "tag_pattern" "module_application" "cons_pattern" "let_open_class_type"))
   ("external" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("field_declaration" ("record_declaration"))
   ("field_expression" ("record_expression"))
   ("field_get_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "set_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("field_name" ("field_declaration" "field_path"))
   ("field_path" ("field_pattern" "field_expression" "field_get_expression"))
   ("field_pattern" ("record_binding_pattern" "record_pattern"))
   ("floating_attribute" ("attribute_payload" "object_expression" "structure" "_structure_item" "compilation_unit" "class_body_type" "signature" "_signature_item"))
   ("for_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("fun_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("function_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("function_type" ("attribute_payload" "local_open_type" "coercion_expression" "instantiated_class" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("functor" ("typed_module_expression" "include_module" "parenthesized_module_expression" "functor" "open_module" "module_application" "_module_expression" "package_expression" "module_binding" "module_type_of"))
   ("functor_type" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("guard" ("match_case" "attribute_payload"))
   ("hash_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("hash_operator" ("parenthesized_operator" "hash_expression"))
   ("hash_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("if_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("include_module" ("_structure_item" "attribute_payload" "structure"))
   ("include_module_type" ("attribute_payload" "compilation_unit" "signature" "_signature_item"))
   ("indexing_operator" ("parenthesized_operator" "indexing_operator_path"))
   ("indexing_operator_path" ("bigarray_get_expression" "array_get_expression" "string_get_expression"))
   ("infix_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("inheritance_definition" ("_class_field" "object_expression"))
   ("inheritance_specification" ("_class_field_specification" "class_body_type"))
   ("instance_variable_definition" ("_class_field" "object_expression"))
   ("instance_variable_expression" ("object_copy_expression"))
   ("instance_variable_name" ("set_expression" "instance_variable_expression" "instance_variable_definition" "instance_variable_specification"))
   ("instance_variable_specification" ("_class_field_specification" "class_body_type"))
   ("instantiated_class" ("_simple_class_expression" "class_application"))
   ("instantiated_class_type" ("class_type_binding" "let_open_class_type" "_simple_class_type" "inheritance_specification"))
   ("item_attribute" ("quoted_item_extension" "let_binding" "module_binding" "value_specification" "include_module_type" "open_module" "class_initializer" "class_type_binding" "external" "method_definition" "inheritance_specification" "instance_variable_definition" "include_module" "class_binding" "inheritance_definition" "module_type_definition" "instance_variable_specification" "item_extension" "exception_definition" "method_specification" "expression_item" "type_parameter_constraint" "type_binding"))
   ("item_extension" ("attribute_payload" "object_expression" "structure" "_structure_item" "compilation_unit" "_class_field" "class_body_type" "_class_field_specification" "signature" "_signature_item"))
   ("label_name" ("class_function_type" "labeled_argument" "typed_label" "parameter"))
   ("labeled_argument" ("application_expression" "class_application"))
   ("lazy_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("lazy_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "_effect_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("let_and_operator" ("parenthesized_operator" "value_definition"))
   ("let_binding" ("value_definition"))
   ("let_class_expression" ("class_function" "typed_class_expression" "parenthesized_class_expression" "let_open_class_expression" "let_class_expression" "inheritance_definition" "class_binding" "_class_expression"))
   ("let_exception_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("let_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("let_module_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("let_open_class_expression" ("class_function" "typed_class_expression" "parenthesized_class_expression" "let_open_class_expression" "let_class_expression" "inheritance_definition" "class_binding" "_class_expression"))
   ("let_open_class_type" ("class_type_binding" "let_open_class_type" "_simple_class_type" "inheritance_specification"))
   ("let_open_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("let_operator" ("parenthesized_operator" "value_definition"))
   ("list_binding_pattern" ("local_open_pattern"))
   ("list_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("list_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("local_open_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("local_open_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("local_open_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("match_case" ("match_expression" "try_expression" "function_expression"))
   ("match_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("match_operator" ("match_expression" "parenthesized_operator"))
   ("method_definition" ("_class_field" "object_expression"))
   ("method_invocation" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("method_name" ("method_invocation" "method_definition" "method_specification" "method_type"))
   ("method_specification" ("_class_field_specification" "class_body_type"))
   ("method_type" ("object_type"))
   ("module_application" ("typed_module_expression" "include_module" "parenthesized_module_expression" "functor" "open_module" "module_application" "_module_expression" "package_expression" "module_binding" "module_type_of"))
   ("module_binding" ("module_definition"))
   ("module_definition" ("attribute_payload" "structure" "_structure_item" "signature" "compilation_unit" "let_module_expression" "_signature_item"))
   ("module_name" ("module_parameter" "extended_module_path" "module_path" "package_pattern" "module_binding"))
   ("module_parameter" ("functor" "module_binding" "functor_type"))
   ("module_path" ("value_path" "local_open_expression" "field_path" "package_expression" "module_binding" "indexing_operator_path" "typed_module_expression" "local_open_pattern" "constrain_module" "toplevel_directive" "parenthesized_module_expression" "open_module" "module_type_of" "include_module" "class_path" "module_path" "functor" "constructor_path" "module_application" "_module_expression"))
   ("module_type_constraint" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("module_type_definition" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("module_type_name" ("module_type_path" "module_type_definition"))
   ("module_type_of" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("module_type_path" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("mult_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("new_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("number" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("object_copy_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("object_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "_simple_class_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("object_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("ocamlyacc_value" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("open_module" ("attribute_payload" "structure" "_structure_item" "let_open_class_expression" "let_open_expression" "compilation_unit" "signature" "let_open_class_type" "_signature_item"))
   ("or_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("or_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("package_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("package_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("package_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("packed_module" ("module_application" "_simple_module_expression"))
   ("parameter" ("method_definition" "class_function" "fun_expression" "_parameter" "class_binding" "let_binding"))
   ("parenthesized_class_expression" ("_simple_class_expression" "class_application"))
   ("parenthesized_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("parenthesized_module_expression" ("module_application" "_simple_module_expression"))
   ("parenthesized_module_type" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("parenthesized_operator" ("tuple_pattern" "value_path" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "value_specification" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "external" "inheritance_definition" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "for_expression" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("parenthesized_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("parenthesized_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("polymorphic_type" ("method_definition" "external" "_polymorphic_type" "method_specification" "value_specification" "field_declaration" "let_binding" "method_type"))
   ("polymorphic_variant_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("polymorphic_variant_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("pow_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("prefix_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("prefix_operator" ("parenthesized_operator" "prefix_expression"))
   ("pretty_printing_indication" ("string_content" "quoted_string_content"))
   ("product_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("quoted_extension" ("tuple_type" "functor_type" "let_binding" "prefix_expression" "module_parameter" "constructed_type" "constrain_module_type" "constructor_pattern" "typed_label" "function_type" "hash_expression" "field_get_expression" "_type" "package_type" "type_binding" "application_expression" "_simple_pattern" "package_expression" "lazy_expression" "_simple_module_expression" "hash_type" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "packed_module" "tag_specification" "_module_type" "_simple_expression" "list_pattern" "module_type_definition" "constrain_type" "effect_pattern" "parenthesized_type" "array_get_expression" "_simple_class_type" "method_invocation" "attribute_payload" "parenthesized_module_type" "lazy_pattern" "or_pattern" "local_open_type" "coercion_expression" "_simple_class_expression" "_binding_pattern" "typed_module_expression" "labeled_argument" "include_module_type" "field_expression" "parenthesized_pattern" "assert_expression" "class_body_type" "polymorphic_type" "parameter" "class_type_binding" "inheritance_specification" "instance_variable_definition" "package_pattern" "module_type_constraint" "string_get_expression" "bigarray_get_expression" "instantiated_class_type" "object_type" "field_pattern" "type_parameter_constraint" "array_pattern" "tuple_pattern" "alias_pattern" "instantiated_class" "module_binding" "constructor_declaration" "array_binding_pattern" "_tuple_type" "class_function_type" "local_open_pattern" "typed_pattern" "_simple_type" "class_application" "record_expression" "aliased_type" "typed_expression" "instance_variable_specification" "list_binding_pattern" "tag_pattern" "module_application" "cons_pattern" "let_open_class_type"))
   ("quoted_item_extension" ("attribute_payload" "object_expression" "structure" "_structure_item" "compilation_unit" "_class_field" "class_body_type" "_class_field_specification" "signature" "_signature_item"))
   ("quoted_string" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("quoted_string_content" ("quoted_item_extension" "quoted_string" "quoted_extension"))
   ("range_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("record_binding_pattern" ("local_open_pattern"))
   ("record_declaration" ("type_binding" "constructor_declaration"))
   ("record_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "string_get_expression" "assert_expression" "local_open_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("record_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("refutation_case" ("match_case"))
   ("rel_operator" ("parenthesized_operator" "infix_expression" "_infix_operator"))
   ("sequence_expression" ("while_expression" "coercion_expression" "local_open_expression" "let_binding" "fun_expression" "let_open_expression" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "parameter" "match_expression" "method_definition" "let_exception_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "bigarray_get_expression" "try_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "parenthesized_expression"))
   ("set_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("sign_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("sign_operator" ("sign_expression"))
   ("signature" ("module_parameter" "typed_module_expression" "parenthesized_module_type" "include_module_type" "functor_type" "packed_module" "constrain_module_type" "package_pattern" "module_type_definition" "module_type_constraint" "_module_type" "package_expression" "package_type" "module_binding"))
   ("signed_number" ("effect_pattern" "_simple_pattern" "_signed_constant" "range_pattern" "parameter"))
   ("string" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "external" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("string_content" ("string"))
   ("string_get_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "set_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("structure" ("typed_module_expression" "include_module" "parenthesized_module_expression" "functor" "open_module" "module_application" "_module_expression" "package_expression" "module_binding" "module_type_of"))
   ("tag" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "_binding_pattern" "let_binding" "prefix_expression" "lazy_expression" "array_binding_pattern" "labeled_argument" "local_open_pattern" "polymorphic_variant_type" "typed_pattern" "parenthesized_pattern" "tag_specification" "assert_expression" "constructor_pattern" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "list_pattern" "string_get_expression" "bigarray_get_expression" "list_binding_pattern" "effect_pattern" "tag_pattern" "array_get_expression" "field_pattern" "application_expression" "array_pattern" "_simple_pattern" "method_invocation" "cons_pattern"))
   ("tag_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "_effect_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("tag_specification" ("polymorphic_variant_type"))
   ("then_clause" ("if_expression"))
   ("toplevel_directive" ("attribute_payload" "structure"))
   ("try_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
   ("tuple_pattern" ("tuple_pattern" "attribute_payload" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "object_expression" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "_pattern" "constructor_pattern" "parameter" "match_case" "exception_pattern" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("tuple_type" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("type_binding" ("type_definition"))
   ("type_constraint" ("type_binding" "constrain_type"))
   ("type_constructor" ("type_constructor_path" "abstract_type" "type_binding"))
   ("type_constructor_path" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "polymorphic_variant_pattern" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("type_definition" ("attribute_payload" "structure" "_structure_item" "compilation_unit" "signature" "_signature_item"))
   ("type_parameter_constraint" ("_class_field" "_class_field_specification" "object_expression" "class_body_type"))
   ("type_variable" ("attribute_payload" "tuple_type" "local_open_type" "coercion_expression" "instantiated_class" "constructor_declaration" "class_function_type" "_tuple_type" "hash_type" "labeled_argument" "object_expression" "polymorphic_variant_type" "type_constraint" "fun_expression" "typed_pattern" "constructed_type" "field_expression" "tag_specification" "class_body_type" "polymorphic_type" "_simple_type" "typed_label" "parameter" "function_type" "class_type_binding" "aliased_type" "instance_variable_definition" "typed_expression" "_type" "class_binding" "instance_variable_specification" "instantiated_class_type" "constrain_type" "object_type" "parenthesized_type" "field_pattern" "type_binding" "type_parameter_constraint"))
   ("typed_class_expression" ("_simple_class_expression" "class_application"))
   ("typed_expression" ("labeled_argument" "class_application" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("typed_label" ("function_type"))
   ("typed_module_expression" ("module_application" "_simple_module_expression"))
   ("typed_pattern" ("tuple_pattern" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "parameter" "list_pattern" "list_binding_pattern" "effect_pattern" "tag_pattern" "field_pattern" "array_pattern" "_simple_pattern" "cons_pattern"))
   ("unit" ("prefix_expression" "range_pattern" "lazy_expression" "labeled_argument" "_constant" "toplevel_directive" "assert_expression" "_simple_expression" "parameter" "class_application" "record_expression" "hash_expression" "field_get_expression" "_signed_constant" "string_get_expression" "bigarray_get_expression" "effect_pattern" "array_get_expression" "application_expression" "_simple_pattern" "method_invocation"))
   ("value_definition" ("attribute_payload" "structure" "_structure_item" "let_class_expression" "let_expression"))
   ("value_name" ("tuple_pattern" "value_path" "alias_pattern" "lazy_pattern" "or_pattern" "let_binding" "_binding_pattern" "array_binding_pattern" "local_open_pattern" "value_specification" "typed_pattern" "parenthesized_pattern" "constructor_pattern" "external" "list_pattern" "list_binding_pattern" "tag_pattern" "field_pattern" "array_pattern" "cons_pattern"))
   ("value_path" ("labeled_argument" "class_application" "toplevel_directive" "record_expression" "array_get_expression" "hash_expression" "field_get_expression" "application_expression" "assert_expression" "string_get_expression" "method_invocation" "_simple_expression" "prefix_expression" "bigarray_get_expression" "lazy_expression"))
   ("value_pattern" ("effect_pattern" "alias_pattern" "for_expression" "inheritance_definition" "_simple_pattern" "parameter"))
   ("value_specification" ("attribute_payload" "compilation_unit" "signature" "_signature_item"))
   ("variant_declaration" ("type_binding"))
   ("while_expression" ("while_expression" "_expression" "coercion_expression" "sign_expression" "let_binding" "local_open_expression" "infix_expression" "fun_expression" "let_open_expression" "field_expression" "packed_module" "if_expression" "class_initializer" "_sequence_expression" "let_module_expression" "then_clause" "parameter" "match_expression" "method_definition" "let_exception_expression" "else_clause" "product_expression" "instance_variable_definition" "guard" "typed_expression" "match_case" "sequence_expression" "string_get_expression" "array_expression" "bigarray_get_expression" "try_expression" "cons_expression" "expression_item" "array_get_expression" "for_expression" "let_expression" "do_clause" "list_expression" "set_expression" "instance_variable_expression" "parenthesized_expression"))
  )
)
;; END Inverse production rules for ocamli
;; START All node types in ocamli
(defconst combobulate-rules-ocaml-interface-types
 '("_binding_pattern" "_class_expression" "_class_field" "_class_field_specification" "_class_type" "_constant" "_effect_pattern" "_expression" "_infix_operator" "_module_expression" "_module_type" "_parameter" "_pattern" "_polymorphic_type" "_sequence_expression" "_signature_item" "_signed_constant" "_simple_class_expression" "_simple_class_type" "_simple_expression" "_simple_module_expression" "_simple_pattern" "_simple_type" "_structure_item" "_tuple_type" "_type" "abstract_type" "add_operator" "alias_pattern" "aliased_type" "and_operator" "application_expression" "array_binding_pattern" "array_expression" "array_get_expression" "array_pattern" "assert_expression" "assign_operator" "attribute" "attribute_id" "attribute_payload" "bigarray_get_expression" "boolean" "character" "character_content" "class_application" "class_binding" "class_body_type" "class_definition" "class_function" "class_function_type" "class_initializer" "class_name" "class_path" "class_type_binding" "class_type_definition" "class_type_name" "class_type_path" "coercion_expression" "comment" "compilation_unit" "concat_operator" "cons_expression" "cons_pattern" "constrain_module" "constrain_module_type" "constrain_type" "constructed_type" "constructor_declaration" "constructor_name" "constructor_path" "constructor_pattern" "conversion_specification" "directive" "do_clause" "effect_pattern" "else_clause" "escape_sequence" "exception_definition" "exception_pattern" "expression_item" "extended_module_path" "extension" "external" "field_declaration" "field_expression" "field_get_expression" "field_name" "field_path" "field_pattern" "floating_attribute" "for_expression" "fun_expression" "function_expression" "function_type" "functor" "functor_type" "guard" "hash_expression" "hash_operator" "hash_type" "if_expression" "include_module" "include_module_type" "indexing_operator" "indexing_operator_path" "infix_expression" "inheritance_definition" "inheritance_specification" "instance_variable_definition" "instance_variable_expression" "instance_variable_name" "instance_variable_specification" "instantiated_class" "instantiated_class_type" "item_attribute" "item_extension" "label_name" "labeled_argument" "lazy_expression" "lazy_pattern" "let_and_operator" "let_binding" "let_class_expression" "let_exception_expression" "let_expression" "let_module_expression" "let_open_class_expression" "let_open_class_type" "let_open_expression" "let_operator" "line_number_directive" "list_binding_pattern" "list_expression" "list_pattern" "local_open_expression" "local_open_pattern" "local_open_type" "match_case" "match_expression" "match_operator" "method_definition" "method_invocation" "method_name" "method_specification" "method_type" "module_application" "module_binding" "module_definition" "module_name" "module_parameter" "module_path" "module_type_constraint" "module_type_definition" "module_type_name" "module_type_of" "module_type_path" "mult_operator" "new_expression" "number" "object_copy_expression" "object_expression" "object_type" "ocamlyacc_value" "open_module" "or_operator" "or_pattern" "package_expression" "package_pattern" "package_type" "packed_module" "parameter" "parenthesized_class_expression" "parenthesized_expression" "parenthesized_module_expression" "parenthesized_module_type" "parenthesized_operator" "parenthesized_pattern" "parenthesized_type" "polymorphic_type" "polymorphic_variant_pattern" "polymorphic_variant_type" "pow_operator" "prefix_expression" "prefix_operator" "pretty_printing_indication" "product_expression" "quoted_extension" "quoted_item_extension" "quoted_string" "quoted_string_content" "range_pattern" "record_binding_pattern" "record_declaration" "record_expression" "record_pattern" "refutation_case" "rel_operator" "sequence_expression" "set_expression" "sign_expression" "sign_operator" "signature" "signed_number" "string" "string_content" "string_get_expression" "structure" "tag" "tag_pattern" "tag_specification" "then_clause" "toplevel_directive" "try_expression" "tuple_pattern" "tuple_type" "type_binding" "type_constraint" "type_constructor" "type_constructor_path" "type_definition" "type_parameter_constraint" "type_variable" "typed_class_expression" "typed_expression" "typed_label" "typed_module_expression" "typed_pattern" "unit" "value_definition" "value_name" "value_path" "value_pattern" "value_specification" "variant_declaration" "while_expression")
)
;; END All node types in ocamli
;; START All supertypes in ocamli
(defconst combobulate-rules-ocaml-interface-supertypes
 '("_binding_pattern" "_class_expression" "_class_field" "_class_field_specification" "_class_type" "_constant" "_effect_pattern" "_expression" "_infix_operator" "_module_expression" "_module_type" "_parameter" "_pattern" "_polymorphic_type" "_sequence_expression" "_signature_item" "_signed_constant" "_simple_class_expression" "_simple_class_type" "_simple_expression" "_simple_module_expression" "_simple_pattern" "_simple_type" "_structure_item" "_tuple_type" "_type")
)
;; END All supertypes in ocamli

;; START Auto-generated list of all languages
(defconst combobulate-rules-languages
 '(css go html javascript json ocaml ocamli python toml tsx typescript yaml)
 "A list of all the languages that have production rules.")
;; END Auto-generated list of all languages
(defconst combobulate-rules-alist
 `((css ,combobulate-rules-css)
 (go ,combobulate-rules-go)
 (html ,combobulate-rules-html)
 (javascript ,combobulate-rules-javascript)
 (json ,combobulate-rules-json)
 (ocaml ,combobulate-rules-ocaml)
 (ocamli ,combobulate-rules-ocaml-interface)
 (python ,combobulate-rules-python)
 (toml ,combobulate-rules-toml)
 (tsx ,combobulate-rules-tsx)
 (typescript ,combobulate-rules-typescript)
 (yaml ,combobulate-rules-yaml)
))

(defconst combobulate-rules-inverse-alist
 `((css ,combobulate-rules-css-inverse)
 (go ,combobulate-rules-go-inverse)
 (html ,combobulate-rules-html-inverse)
 (javascript ,combobulate-rules-javascript-inverse)
 (json ,combobulate-rules-json-inverse)
 (ocaml ,combobulate-rules-ocaml-inverse)
 (ocamli ,combobulate-rules-ocaml-interface-inverse)
 (python ,combobulate-rules-python-inverse)
 (toml ,combobulate-rules-toml-inverse)
 (tsx ,combobulate-rules-tsx-inverse)
 (typescript ,combobulate-rules-typescript-inverse)
 (yaml ,combobulate-rules-yaml-inverse)
))

(defconst combobulate-rules-types-alist
 `((css ,combobulate-rules-css-types)
 (go ,combobulate-rules-go-types)
 (html ,combobulate-rules-html-types)
 (javascript ,combobulate-rules-javascript-types)
 (json ,combobulate-rules-json-types)
 (ocaml ,combobulate-rules-ocaml-types)
 (ocamli ,combobulate-rules-ocaml-interface-types)
 (python ,combobulate-rules-python-types)
 (toml ,combobulate-rules-toml-types)
 (tsx ,combobulate-rules-tsx-types)
 (typescript ,combobulate-rules-typescript-types)
 (yaml ,combobulate-rules-yaml-types)
))

(defconst combobulate-rules-supertypes-alist
 `((css ,combobulate-rules-css-supertypes)
 (go ,combobulate-rules-go-supertypes)
 (html ,combobulate-rules-html-supertypes)
 (javascript ,combobulate-rules-javascript-supertypes)
 (json ,combobulate-rules-json-supertypes)
 (ocaml ,combobulate-rules-ocaml-supertypes)
 (ocamli ,combobulate-rules-ocaml-interface-supertypes)
 (python ,combobulate-rules-python-supertypes)
 (toml ,combobulate-rules-toml-supertypes)
 (tsx ,combobulate-rules-tsx-supertypes)
 (typescript ,combobulate-rules-typescript-supertypes)
 (yaml ,combobulate-rules-yaml-supertypes)
))

(provide 'combobulate-rules)
